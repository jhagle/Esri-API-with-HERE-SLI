{
	"version": 3,
	"file": "mapsjs-mapeventsjs",
	"lineCount": 28,
	"mappings": "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",
	"sources": [
		"/home/here/repo/ext-events/dev/node_modules/closure-library/closure/goog/base.js",
		"out/tmp/src/mapevents/Pointer.js",
		"out/tmp/src/mapevents/util.js",
		"out/tmp/src/mapevents/Event.js",
		"out/tmp/src/mapevents/PointerList.js",
		"/home/here/repo/ext-events/dev/node_modules/closure-library/closure/goog/disposable/disposable.js",
		"out/tmp/src/mapevents/handlers/Handler.js",
		"out/tmp/src/mapevents/handlers/Touch.js",
		"out/tmp/src/mapevents/handlers/MSPointer.js",
		"out/tmp/src/mapevents/WheelEvent.js",
		"out/tmp/src/mapevents/handlers/Wheel.js",
		"out/tmp/src/mapevents/handlers/Mouse.js",
		"out/tmp/src/mapevents/MapEvents.js",
		"out/tmp/src/mapevents/Behavior.js",
		"out/tmp/src/mapevents/namespace.js"
	],
	"names": [
		"goog.global",
		"goog.UID_PROPERTY_",
		"Math",
		"random",
		"goog.uidCounter_",
		"goog.bindNative_",
		"fn",
		"selfObj",
		"var_args",
		"call",
		"apply",
		"bind",
		"arguments",
		"goog.bindJs_",
		"Error",
		"length",
		"boundArgs",
		"Array",
		"prototype",
		"slice",
		"newArgs",
		"unshift",
		"goog.bind",
		"Function",
		"toString",
		"indexOf",
		"goog.bind.apply",
		"goog.exportSymbol",
		"publicPath",
		"object",
		"parts",
		"split",
		"cur",
		"execScript",
		"part",
		"shift",
		"undefined",
		"H.mapevents.Pointer",
		"viewportX",
		"viewportY",
		"id",
		"type",
		"isNaN",
		"H.mapevents.Pointer.prototype.updatePosition",
		"x",
		"y",
		"H.mapevents.util.findOffset",
		"element",
		"doc",
		"ownerDocument",
		"docElement",
		"documentElement",
		"body",
		"parentNode",
		"clientRect",
		"getBoundingClientRect",
		"window",
		"pageXOffset",
		"scrollLeft",
		"pageYOffset",
		"scrollTop",
		"H.mapevents.Event",
		"pointers",
		"changedPointers",
		"targetPointers",
		"currentPointer",
		"target",
		"originalEvent",
		"H",
		"util",
		"getSuperProto",
		"constructor",
		"lang",
		"inherits",
		"Event",
		"H.mapevents.PointerList",
		"opt_pointers",
		"list_",
		"H$mapevents$PointerList.prototype",
		"H.mapevents.PointerList.prototype",
		"clear",
		"H.mapevents.PointerList.prototype.clear",
		"splice",
		"H.mapevents.PointerList.prototype.length",
		"item",
		"H.mapevents.PointerList.prototype.item",
		"idx",
		"H.mapevents.PointerList.prototype.indexOf",
		"pointerId",
		"i",
		"H.mapevents.PointerList.prototype.byId",
		"remove",
		"H.mapevents.PointerList.prototype.remove",
		"H.mapevents.PointerList.prototype.removeByType",
		"list",
		"push",
		"H.mapevents.PointerList.prototype.isDragTarget",
		"obj",
		"H.mapevents.PointerList.prototype.push",
		"pointer",
		"asArray",
		"H.mapevents.PointerList.prototype.asArray",
		"clone",
		"H.mapevents.PointerList.prototype.clone",
		"goog.Disposable",
		"goog.Disposable.MONITORING_MODE",
		"goog.Disposable.MonitoringMode.OFF",
		"goog.Disposable.instances_",
		"OFF",
		"disposed_",
		"dispose",
		"goog.Disposable.prototype.dispose",
		"disposeInternal",
		"uid",
		"addOnDisposeCallback",
		"goog.Disposable.prototype.addOnDisposeCallback",
		"callback",
		"opt_scope",
		"onDisposeCallbacks_",
		"goog.Disposable.prototype.disposeInternal",
		"H.mapevents.handlers.Handler",
		"map",
		"eventsMap",
		"opt_options",
		"options",
		"Map",
		"goog.Disposable.call",
		"dblTapThreshold",
		"dblTapDistanceThreshold",
		"tapDistanceThreshold",
		"tapThreshold",
		"longPressThreshold",
		"longPressDistanceThreshold",
		"viewPort_",
		"getViewPort",
		"eventsMap_",
		"lastPointerDown_",
		"dragging_",
		"firstDragMove_",
		"nextDrag_",
		"longPress_",
		"lastTapped_",
		"createOngoingDrag_",
		"eventDispatcher_",
		"dispatchpointerdown",
		"dispatchpointermove",
		"dispatchpointerup",
		"dispatchpointercancel",
		"addRemoveListeners_",
		"H.mapevents.handlers.Handler.prototype.addRemoveListeners_",
		"opt_remove",
		"listener",
		"handler",
		"l",
		"removeEventListener",
		"eventName",
		"addEventListener",
		"H.mapevents.handlers.Handler.prototype.processPointerEvent",
		"name",
		"originalEvt",
		"pointerTarget",
		"dispatchFunc",
		"contains",
		"getObjectAt",
		"cancelScheduled_",
		"H$mapevents$handlers$Handler.prototype",
		"H.mapevents.handlers.Handler.prototype",
		"H.mapevents.handlers.Handler.prototype.dispatchpointerup",
		"resolveDragEnd_",
		"dispatchOnObject",
		"lastPointerDown",
		"resolveTap_",
		"currentPos",
		"currentTimeStamp",
		"at",
		"distance",
		"ts",
		"evtName",
		"math",
		"Point",
		"H.mapevents.handlers.Handler.prototype.resolveDragEnd_",
		"dragTarget",
		"H.mapevents.handlers.Handler.prototype.createOngoingDrag_",
		"that",
		"setTimeout",
		"H.mapevents.handlers.Handler.CONTINUE_DRAG_TIME_",
		"H.mapevents.handlers.Handler.prototype.cancelScheduled_",
		"scheduleMap",
		"clearTimeout",
		"H.mapevents.handlers.Handler.prototype.setupLongpress_",
		"lastDownTarget",
		"startPoint",
		"H.mapevents.handlers.Handler.prototype.dispatchpointermove",
		"prevTarget",
		"H.mapevents.handlers.Handler.prototype.dispatchpointerdown",
		"pointerType",
		"canDrag",
		"button",
		"evt",
		"draggable",
		"isDragTarget",
		"setupLongpress_",
		"H.mapevents.handlers.Handler.prototype.dispatchpointercancel",
		"H.mapevents.handlers.Handler.prototype.dispatchOnObject",
		"onTarget",
		"H.mapevents.handlers.Handler.prototype.disposeInternal",
		"H.mapevents.handlers.Touch",
		"handleTouch",
		"H.mapevents.handlers.Handler.call",
		"touchToPointers_",
		"imprintLinks_",
		"imprintElement",
		"imprint",
		"getImprint",
		"getElement",
		"querySelectorAll",
		"H.mapevents.handlers.Touch.prototype.handleTouch",
		"touches",
		"pointersLen",
		"handleLostPointers",
		"clonedPointerList",
		"processPointerEvent",
		"offset",
		"managePointers",
		"evtType",
		"changedTouches",
		"absX",
		"absY",
		"touch",
		"byId",
		"abs",
		"updatePosition",
		"H.mapevents.handlers.Touch.prototype.disposeInternal",
		"H.mapevents.handlers.MSPointer",
		"handlers",
		"createHandlerMap_",
		"navigator",
		"H.mapevents.handlers.MSPointer.prototype.createHandlerMap_",
		"isIE11",
		"platformEventName",
		"handlerMap",
		"handlePointerEvent",
		"forEach",
		"msEventName",
		"toLowerCase",
		"replace",
		"H.mapevents.handlers.MSPointer.NumToType",
		"TOUCH",
		"PEN",
		"MOUSE",
		"createPointer",
		"H.mapevents.handlers.MSPointer.prototype.createPointer",
		"atCoords",
		"H.mapevents.handlers.MSPointer.prototype.handlePointerEvent",
		"pointerEnabled",
		"removeByType",
		"document",
		"H.mapevents.WheelEvent",
		"deltaY",
		"H.mapevents.handlers.Wheel",
		"IS_W3C_CONFORM",
		"IS_W3C_CONFORM_",
		"DELTA_PREFIX_",
		"handleWheel",
		"normalize",
		"H.mapevents.handlers.Wheel.prototype.normalize",
		"DELTA_PREFIX",
		"absDeltaY",
		"deltaO",
		"H.mapevents.handlers.Wheel.prototype.handleWheel",
		"normalizedEvent",
		"getObjectsAt",
		"H.mapevents.handlers.Mouse",
		"win",
		"handleMouse",
		"ondragstart_",
		"H.mapevents.handlers.Mouse.prototype.createPointer",
		"H.mapevents.handlers.Mouse.prototype.handleMouse",
		"H.mapevents.handlers.Mouse.prototype.ondragstart_",
		"preventDefault",
		"H.mapevents.MapEvents",
		"H.mapevents.MapEvents.usedBy_.indexOf",
		"map_",
		"H.mapevents.MapEvents.usedBy_.push",
		"wheelHandler_",
		"mouseHandler_",
		"touchHandler_",
		"setupHandlers_",
		"Disposable",
		"H.mapevents.MapEvents.usedBy_",
		"H.mapevents.MapEvents.prototype.dispose",
		"H.mapevents.MapEvents.usedBy_.splice",
		"goog.exportProperty",
		"getAttachedMap",
		"H.mapevents.MapEvents.prototype.getAttachedMap",
		"H.mapevents.Behavior",
		"mapEvents",
		"H.mapevents.Behavior.usedBy_.indexOf",
		"opts",
		"mapEvents_",
		"H.mapevents.Behavior.usedBy_.push",
		"kinetics_",
		"animation",
		"ease",
		"EASE_OUT_QUAD",
		"enableAll_",
		"enable",
		"engineType",
		"viewPortElement_",
		"viewModel_",
		"getViewModel",
		"p2dType_",
		"style",
		"msTouchAction",
		"touchAction",
		"ondrag_",
		"ondragend_",
		"onwheel_",
		"ondoubletap_",
		"ontap_",
		"pointermove_",
		"events",
		"listen",
		"oncontextmenu_",
		"H.mapevents.Behavior.usedBy_",
		"enabled_",
		"H.mapevents.Behavior.DRAGGING",
		"H.mapevents.Behavior.WHEELZOOM",
		"H.mapevents.Behavior.DBLTAPZOOM",
		"H$mapevents$Behavior.prototype",
		"H.mapevents.Behavior.prototype",
		"H.mapevents.Behavior.prototype.ondragstart_",
		"viewPort",
		"pointer1",
		"pointer2",
		"H.mapevents.Behavior.prototype.ondrag_",
		"H.mapevents.Behavior.prototype.ondragend_",
		"zoom",
		"H.mapevents.Behavior.prototype.zoom",
		"from",
		"to",
		"atX",
		"atY",
		"delta",
		"vm",
		"endView",
		"H.mapevents.Behavior.prototype.onwheel_",
		"startZoom",
		"targetZoom",
		"getZoom",
		"getEngine",
		"cam",
		"getCameraData",
		"setCameraData",
		"H.mapevents.Behavior.prototype.ontap_",
		"engine",
		"screenToCameraData",
		"H.mapevents.Behavior.prototype.pointermove_",
		"setPointer",
		"H.mapevents.Behavior.prototype.ondoubletap_",
		"H.mapevents.Behavior.prototype.oncontextmenu_",
		"H.mapevents.Behavior.prototype.dispose",
		"unlisten",
		"onzoomsync_",
		"H.mapevents.Behavior.usedBy_.splice",
		"disable",
		"H.mapevents.Behavior.prototype.disable",
		"opt_behavior",
		"endInteraction",
		"H.mapevents.Behavior.prototype.enable",
		"isEnabled",
		"H.mapevents.Behavior.prototype.isEnabled",
		"behavior",
		"H.mapevents.buildInfo",
		"BuildInfo",
		"get"
	],
	"sourcesContent": [
		"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will write out Closure's deps file, unless the\n * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to\n * include their own deps file(s) from different locations.\n *\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler when --closure_pass\n *     or --mark_as_compiled is specified.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is\n * already defined in the current scope before assigning to prevent\n * clobbering if base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {}; // Identifies this file as the Closure base.\n\n\n/**\n * Reference to the global context.  In most cases this will be 'window'.\n */\ngoog.global = this;\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production js_binary can be easily stripped\n * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most\n * toString() methods should be declared inside an \"if (goog.DEBUG)\" conditional\n * because they are generally used for debugging purposes and it is difficult\n * for the JSCompiler to statically determine whether they are used.\n */\ngoog.DEBUG = true;\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as JSCompiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.\n */\ngoog.LOCALE = 'en';  // default to en\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your javascript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the JSCompiler.\n */\ngoog.TRUSTED_SITE = true;\n\n\n/**\n * Creates object stubs for a namespace.  The presence of one or more\n * goog.provide() calls indicate that the file defines the given\n * objects/namespaces.  Build tools also scan for provide/require statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n * @see goog.require\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n */\ngoog.provide = function(name) {\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice. This is intended\n    // to teach new developers that 'goog.provide' is effectively a variable\n    // declaration. And when JSCompiler transforms goog.provide into a real\n    // variable declaration, the compiled JS should work the same as the raw\n    // JS--even when the raw JS uses goog.provide incorrectly.\n    if (goog.isProvided_(name)) {\n      throw Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name);\n};\n\n\n/**\n * Marks that the current file should only be used for testing, and never for\n * live code in production.\n *\n * In the case of unit tests, the message may optionally be an exact\n * namespace for the test (e.g. 'goog.stringTest'). The linter will then\n * ignore the extra provide (if not explicitly defined in the code).\n *\n * @param {string=} opt_message Optional message to add to the error that's\n *     raised when used in production code.\n */\ngoog.setTestOnly = function(opt_message) {\n  if (COMPILED && !goog.DEBUG) {\n    opt_message = opt_message || '';\n    throw Error('Importing test-only code into non-debug environment' +\n                opt_message ? ': ' + opt_message : '.');\n  }\n};\n\n\nif (!COMPILED) {\n\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares\n   * that 'goog' and 'goog.events' must be namespaces.\n   *\n   * @type {Object}\n   * @private\n   */\n  goog.implicitNamespaces_ = {};\n}\n\n\n/**\n * Builds an object structure for the provided namespace path,\n * ensuring that names that already exist are not overwritten. For\n * example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name name of the object that this file defines.\n * @param {*=} opt_object the object to expose at the end of the path.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n * @private\n */\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\n  var parts = name.split('.');\n  var cur = opt_objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && cur.execScript) {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  // Certain browsers cannot parse code in the form for((a in b); c;);\n  // This pattern is produced by the JSCompiler when it collapses the\n  // statement above into the conditional loop below. To prevent this from\n  // happening, use a for-loop and reserve the init logic as below.\n\n  // Parentheses added to eliminate strict JS warning in Firefox.\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && goog.isDef(opt_object)) {\n      // last part and we have an object; use it\n      cur[part] = opt_object;\n    } else if (cur[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Returns an object based on its fully qualified external name.  If you are\n * using a compilation pass that renames property names beware that using this\n * function will not find renamed properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} opt_obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, opt_obj) {\n  var parts = name.split('.');\n  var cur = opt_obj || goog.global;\n  for (var part; part = parts.shift(); ) {\n    if (goog.isDefAndNotNull(cur[part])) {\n      cur = cur[part];\n    } else {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Globalizes a whole namespace, such as goog or goog.lang.\n *\n * @param {Object} obj The namespace to globalize.\n * @param {Object=} opt_global The object to add the properties to.\n * @deprecated Properties may be explicitly exported to the global scope, but\n *     this should no longer be done in bulk.\n */\ngoog.globalize = function(obj, opt_global) {\n  var global = opt_global || goog.global;\n  for (var x in obj) {\n    global[x] = obj[x];\n  }\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {Array} provides An array of strings with the names of the objects\n *                         this file provides.\n * @param {Array} requires An array of strings with the names of the objects\n *                         this file requires.\n */\ngoog.addDependency = function(relPath, provides, requires) {\n  if (!COMPILED) {\n    var provide, require;\n    var path = relPath.replace(/\\\\/g, '/');\n    var deps = goog.dependencies_;\n    for (var i = 0; provide = provides[i]; i++) {\n      deps.nameToPath[provide] = path;\n      if (!(path in deps.pathToNames)) {\n        deps.pathToNames[path] = {};\n      }\n      deps.pathToNames[path][provide] = true;\n    }\n    for (var j = 0; require = requires[j]; j++) {\n      if (!(path in deps.requires)) {\n        deps.requires[path] = {};\n      }\n      deps.requires[path][require] = true;\n    }\n  }\n};\n\n\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an orignal\n// way to do \"debug-mode\" development.  The dependency system can sometimes\n// be confusing, as can the debug DOM loader's asyncronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the\n// script will not load until some point after the current script.  If a\n// namespace is needed at runtime, it needs to be defined in a previous\n// script, or loaded via require() with its registered dependencies.\n// User-defined namespaces may need their own deps file.  See http://go/js_deps,\n// http://go/genjsdeps, or, externally, DepsWriter.\n// http://code.google.com/closure/library/docs/depswriter.html\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work is being done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.ENABLE_DEBUG_LOADER = true;\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies\n * that works in parallel with the BUILD system. Note that all calls\n * to goog.require will be stripped by the JSCompiler when the\n * --closure_pass option is used.\n * @see goog.provide\n * @param {string} name Namespace to include (as was given in goog.provide())\n *     in the form \"goog.package.part\".\n */\ngoog.require = function(name) {\n\n  // if the object already exists we do not need do do anything\n  // TODO(arv): If we start to support require based on file name this has\n  //            to change\n  // TODO(arv): If we allow goog.foo.* this has to change\n  // TODO(arv): If we implement dynamic load after page load we should probably\n  //            not remove this code for the compiled output\n  if (!COMPILED) {\n    if (goog.isProvided_(name)) {\n      return;\n    }\n\n    if (goog.ENABLE_DEBUG_LOADER) {\n      var path = goog.getPathFromDeps_(name);\n      if (path) {\n        goog.included_[path] = true;\n        goog.writeScripts_();\n        return;\n      }\n    }\n\n    var errorMessage = 'goog.require could not find: ' + name;\n    if (goog.global.console) {\n      goog.global.console['error'](errorMessage);\n    }\n\n\n      throw Error(errorMessage);\n\n  }\n};\n\n\n/**\n * Path for included scripts\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to write out Closure's deps file. By default,\n * the deps are written.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The function is passed the script source, which is a relative URI. It should\n * return true if the script was imported, false otherwise.\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * Null function used for default values of callbacks, etc.\n * @return {void} Nothing.\n */\ngoog.nullFunction = function() {};\n\n\n/**\n * The identity function. Returns its first argument.\n *\n * @param {*=} opt_returnValue The single value that will be returned.\n * @param {...*} var_args Optional trailing arguments. These are ignored.\n * @return {?} The first argument. We can't know the type -- just pass it along\n *      without type.\n * @deprecated Use goog.functions.identity instead.\n */\ngoog.identityFunction = function(opt_returnValue, var_args) {\n  return opt_returnValue;\n};\n\n\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n *\n * Foo.prototype.bar = goog.abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error\n * will be thrown when bar() is invoked.\n *\n * Note: This does not take the name of the function to override as\n * an argument because that would make it more difficult to obfuscate\n * our JavaScript code.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be\n *   overridden.\n */\ngoog.abstractMethod = function() {\n  throw Error('unimplemented abstract method');\n};\n\n\n/**\n * Adds a {@code getInstance} static method that always return the same instance\n * object.\n * @param {!Function} ctor The constructor for the class to add the static\n *     method to.\n */\ngoog.addSingletonGetter = function(ctor) {\n  ctor.getInstance = function() {\n    if (ctor.instance_) {\n      return ctor.instance_;\n    }\n    if (goog.DEBUG) {\n      // NOTE: JSCompiler can't optimize away Array#push.\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\n    }\n    return ctor.instance_ = new ctor;\n  };\n};\n\n\n/**\n * All singleton classes that have been instantiated, for testing. Don't read\n * it directly, use the {@code goog.testing.singleton} module. The compiler\n * removes this variable if unused.\n * @type {!Array.<!Function>}\n * @private\n */\ngoog.instantiatedSingletons_ = [];\n\n\nif (!COMPILED && goog.ENABLE_DEBUG_LOADER) {\n  /**\n   * Object used to keep track of urls that have already been added. This\n   * record allows the prevention of circular dependencies.\n   * @type {Object}\n   * @private\n   */\n  goog.included_ = {};\n\n\n  /**\n   * This object is used to keep track of dependencies and other data that is\n   * used for loading scripts\n   * @private\n   * @type {Object}\n   */\n  goog.dependencies_ = {\n    pathToNames: {}, // 1 to many\n    nameToPath: {}, // 1 to 1\n    requires: {}, // 1 to many\n    // used when resolving dependencies to prevent us from\n    // visiting the file twice\n    visited: {},\n    written: {} // used to keep track of script files we have written\n  };\n\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    var doc = goog.global.document;\n    return typeof doc != 'undefined' &&\n           'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * Tries to detect the base path of the base.js script that bootstraps Closure\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.global.CLOSURE_BASE_PATH) {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    var doc = goog.global.document;\n    var scripts = doc.getElementsByTagName('script');\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var src = scripts[i].src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n\n  /**\n   * Imports a script if, and only if, that script hasn't already been imported.\n   * (Must be called at execution time)\n   * @param {string} src Script source.\n   * @private\n   */\n  goog.importScript_ = function(src) {\n    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||\n        goog.writeScriptTag_;\n    if (!goog.dependencies_.written[src] && importScript(src)) {\n      goog.dependencies_.written[src] = true;\n    }\n  };\n\n\n  /**\n   * The default implementation of the import function. Writes a script tag to\n   * import the script.\n   *\n   * @param {string} src The script source.\n   * @return {boolean} True if the script was imported, false otherwise.\n   * @private\n   */\n  goog.writeScriptTag_ = function(src) {\n    if (goog.inHtmlDocument_()) {\n      var doc = goog.global.document;\n\n      // If the user tries to require a new symbol after document load,\n      // something has gone terribly wrong. Doing a document.write would\n      // wipe out the page.\n      if (doc.readyState == 'complete') {\n        // Certain test frameworks load base.js multiple times, which tries\n        // to write deps.js each time. If that happens, just fail silently.\n        // These frameworks wipe the page between each load of base.js, so this\n        // is OK.\n        var isDeps = /\\bdeps.js$/.test(src);\n        if (isDeps) {\n          return false;\n        } else {\n          throw Error('Cannot write \"' + src + '\" after document load');\n        }\n      }\n\n      doc.write(\n          '<script type=\"text/javascript\" src=\"' + src + '\"></' + 'script>');\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n\n  /**\n   * Resolves dependencies based on the dependencies added using addDependency\n   * and calls importScript_ in the correct order.\n   * @private\n   */\n  goog.writeScripts_ = function() {\n    // the scripts we need to write this time\n    var scripts = [];\n    var seenScript = {};\n    var deps = goog.dependencies_;\n\n    function visitNode(path) {\n      if (path in deps.written) {\n        return;\n      }\n\n      // we have already visited this one. We can get here if we have cyclic\n      // dependencies\n      if (path in deps.visited) {\n        if (!(path in seenScript)) {\n          seenScript[path] = true;\n          scripts.push(path);\n        }\n        return;\n      }\n\n      deps.visited[path] = true;\n\n      if (path in deps.requires) {\n        for (var requireName in deps.requires[path]) {\n          // If the required name is defined, we assume that it was already\n          // bootstrapped by other means.\n          if (!goog.isProvided_(requireName)) {\n            if (requireName in deps.nameToPath) {\n              visitNode(deps.nameToPath[requireName]);\n            } else {\n              throw Error('Undefined nameToPath for ' + requireName);\n            }\n          }\n        }\n      }\n\n      if (!(path in seenScript)) {\n        seenScript[path] = true;\n        scripts.push(path);\n      }\n    }\n\n    for (var path in goog.included_) {\n      if (!deps.written[path]) {\n        visitNode(path);\n      }\n    }\n\n    for (var i = 0; i < scripts.length; i++) {\n      if (scripts[i]) {\n        goog.importScript_(goog.basePath + scripts[i]);\n      } else {\n        throw Error('Undefined script input');\n      }\n    }\n  };\n\n\n  /**\n   * Looks at the dependency rules and tries to determine the script file that\n   * fulfills a particular rule.\n   * @param {string} rule In the form goog.namespace.Class or project.script.\n   * @return {?string} Url corresponding to the rule, or null.\n   * @private\n   */\n  goog.getPathFromDeps_ = function(rule) {\n    if (rule in goog.dependencies_.nameToPath) {\n      return goog.dependencies_.nameToPath[rule];\n    } else {\n      return null;\n    }\n  };\n\n  goog.findBasePath_();\n\n  // Allow projects to manage the deps files themselves.\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.importScript_(goog.basePath + 'deps.js');\n  }\n}\n\n\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n * operator in such a way that null returns 'null' and arrays return 'array'.\n * @param {*} value The value to get the type of.\n * @return {string} The name of the type.\n */\ngoog.typeOf = function(value) {\n  var s = typeof value;\n  if (s == 'object') {\n    if (value) {\n      // Check these first, so we can avoid calling Object.prototype.toString if\n      // possible.\n      //\n      // IE improperly marshals tyepof across execution contexts, but a\n      // cross-context object will still return false for \"instanceof Object\".\n      if (value instanceof Array) {\n        return 'array';\n      } else if (value instanceof Object) {\n        return s;\n      }\n\n      // HACK: In order to use an Object prototype method on the arbitrary\n      //   value, the compiler requires the value be cast to type Object,\n      //   even though the ECMA spec explicitly allows it.\n      var className = Object.prototype.toString.call(\n          /** @type {Object} */ (value));\n      // In Firefox 3.6, attempting to access iframe window objects' length\n      // property throws an NS_ERROR_FAILURE, so we need to special-case it\n      // here.\n      if (className == '[object Window]') {\n        return 'object';\n      }\n\n      // We cannot always use constructor == Array or instanceof Array because\n      // different frames have different Array objects. In IE6, if the iframe\n      // where the array was created is destroyed, the array loses its\n      // prototype. Then dereferencing val.splice here throws an exception, so\n      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\n      // so that will work. In this case, this function will return false and\n      // most array functions will still work because the array is still\n      // array-like (supports length and []) even though it has lost its\n      // prototype.\n      // Mark Miller noticed that Object.prototype.toString\n      // allows access to the unforgeable [[Class]] property.\n      //  15.2.4.2 Object.prototype.toString ( )\n      //  When the toString method is called, the following steps are taken:\n      //      1. Get the [[Class]] property of this object.\n      //      2. Compute a string value by concatenating the three strings\n      //         \"[object \", Result(1), and \"]\".\n      //      3. Return Result(2).\n      // and this behavior survives the destruction of the execution context.\n      if ((className == '[object Array]' ||\n           // In IE all non value types are wrapped as objects across window\n           // boundaries (not iframe though) so we have to do object detection\n           // for this edge case\n           typeof value.length == 'number' &&\n           typeof value.splice != 'undefined' &&\n           typeof value.propertyIsEnumerable != 'undefined' &&\n           !value.propertyIsEnumerable('splice')\n\n          )) {\n        return 'array';\n      }\n      // HACK: There is still an array case that fails.\n      //     function ArrayImpostor() {}\n      //     ArrayImpostor.prototype = [];\n      //     var impostor = new ArrayImpostor;\n      // this can be fixed by getting rid of the fast path\n      // (value instanceof Array) and solely relying on\n      // (value && Object.prototype.toString.vall(value) === '[object Array]')\n      // but that would require many more function calls and is not warranted\n      // unless closure code is receiving objects from untrusted sources.\n\n      // IE in cross-window calls does not correctly marshal the function type\n      // (it appears just as an object) so we cannot use just typeof val ==\n      // 'function'. However, if the object has a call property, it is a\n      // function.\n      if ((className == '[object Function]' ||\n          typeof value.call != 'undefined' &&\n          typeof value.propertyIsEnumerable != 'undefined' &&\n          !value.propertyIsEnumerable('call'))) {\n        return 'function';\n      }\n\n\n    } else {\n      return 'null';\n    }\n\n  } else if (s == 'function' && typeof value.call == 'undefined') {\n    // In Safari typeof nodeList returns 'function', and on Firefox\n    // typeof behaves similarly for HTML{Applet,Embed,Object}Elements\n    // and RegExps.  We would like to return object for those and we can\n    // detect an invalid function by making sure that the function\n    // object has a call method.\n    return 'object';\n  }\n  return s;\n};\n\n\n/**\n * Returns true if the specified value is not |undefined|.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.  Additionally, this function assumes that the global\n * undefined variable has not been redefined.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\ngoog.isDef = function(val) {\n  return val !== undefined;\n};\n\n\n/**\n * Returns true if the specified value is |null|\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is null.\n */\ngoog.isNull = function(val) {\n  return val === null;\n};\n\n\n/**\n * Returns true if the specified value is defined and not null\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\ngoog.isDefAndNotNull = function(val) {\n  // Note that undefined == null.\n  return val != null;\n};\n\n\n/**\n * Returns true if the specified value is an array\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArray = function(val) {\n  return goog.typeOf(val) == 'array';\n};\n\n\n/**\n * Returns true if the object looks like an array. To qualify as array like\n * the value needs to be either a NodeList or an object with a Number length\n * property.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArrayLike = function(val) {\n  var type = goog.typeOf(val);\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\n};\n\n\n/**\n * Returns true if the object looks like a Date. To qualify as Date-like\n * the value needs to be an object and have a getFullYear() function.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a like a Date.\n */\ngoog.isDateLike = function(val) {\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\n};\n\n\n/**\n * Returns true if the specified value is a string\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\ngoog.isString = function(val) {\n  return typeof val == 'string';\n};\n\n\n/**\n * Returns true if the specified value is a boolean\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is boolean.\n */\ngoog.isBoolean = function(val) {\n  return typeof val == 'boolean';\n};\n\n\n/**\n * Returns true if the specified value is a number\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a number.\n */\ngoog.isNumber = function(val) {\n  return typeof val == 'number';\n};\n\n\n/**\n * Returns true if the specified value is a function\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a function.\n */\ngoog.isFunction = function(val) {\n  return goog.typeOf(val) == 'function';\n};\n\n\n/**\n * Returns true if the specified value is an object.  This includes arrays\n * and functions.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\ngoog.isObject = function(val) {\n  var type = typeof val;\n  return type == 'object' && val != null || type == 'function';\n  // return Object(val) === val also works, but is slower, especially if val is\n  // not an object.\n};\n\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further\n * calls with the same object as a parameter returns the same value. The unique\n * ID is guaranteed to be unique across the current session amongst objects that\n * are passed into {@code getUid}. There is no guarantee that the ID is unique\n * or consistent across sessions. It is unsafe to generate unique ID for\n * function prototypes.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\ngoog.getUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // In Opera window.hasOwnProperty exists but always returns false so we avoid\n  // using it. As a consequence the unique ID generated for BaseClass.prototype\n  // and SubClass.prototype will be the same.\n  return obj[goog.UID_PROPERTY_] ||\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n};\n\n\n/**\n * Removes the unique ID from an object. This is useful if the object was\n * previously mutated using {@code goog.getUid} in which case the mutation is\n * undone.\n * @param {Object} obj The object to remove the unique ID field from.\n */\ngoog.removeUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // DOM nodes in IE are not instance of Object and throws exception\n  // for delete. Instead we try to use removeAttribute\n  if ('removeAttribute' in obj) {\n    obj.removeAttribute(goog.UID_PROPERTY_);\n  }\n  /** @preserveTry */\n  try {\n    delete obj[goog.UID_PROPERTY_];\n  } catch (ex) {\n  }\n};\n\n\n/**\n * Name for unique ID property. Initialized in a way to help avoid collisions\n * with other closure javascript on the same page.\n * @type {string}\n * @private\n */\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * Counter for UID.\n * @type {number}\n * @private\n */\ngoog.uidCounter_ = 0;\n\n\n/**\n * Adds a hash code field to an object. The hash code is unique for the\n * given object.\n * @param {Object} obj The object to get the hash code for.\n * @return {number} The hash code for the object.\n * @deprecated Use goog.getUid instead.\n */\ngoog.getHashCode = goog.getUid;\n\n\n/**\n * Removes the hash code field from an object.\n * @param {Object} obj The object to remove the field from.\n * @deprecated Use goog.removeUid instead.\n */\ngoog.removeHashCode = goog.removeUid;\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\n * refer to themselves will cause infinite recursion.\n *\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\n * UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {*} obj The value to clone.\n * @return {*} A clone of the input value.\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\n */\ngoog.cloneObject = function(obj) {\n  var type = goog.typeOf(obj);\n  if (type == 'object' || type == 'array') {\n    if (obj.clone) {\n      return obj.clone();\n    }\n    var clone = type == 'array' ? [] : {};\n    for (var key in obj) {\n      clone[key] = goog.cloneObject(obj[key]);\n    }\n    return clone;\n  }\n\n  return obj;\n};\n\n\n/**\n * A native implementation of goog.bind.\n * @param {Function} fn A function to partially apply.\n * @param {Object|undefined} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @private\n * @suppress {deprecated} The compiler thinks that Function.prototype.bind\n *     is deprecated because some people have declared a pure-JS version.\n *     Only the pure-JS version is truly deprecated.\n */\ngoog.bindNative_ = function(fn, selfObj, var_args) {\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\n};\n\n\n/**\n * A pure-JS implementation of goog.bind.\n * @param {Function} fn A function to partially apply.\n * @param {Object|undefined} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @private\n */\ngoog.bindJs_ = function(fn, selfObj, var_args) {\n  if (!fn) {\n    throw new Error();\n  }\n\n  if (arguments.length > 2) {\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      // Prepend the bound arguments to the current arguments.\n      var newArgs = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(newArgs, boundArgs);\n      return fn.apply(selfObj, newArgs);\n    };\n\n  } else {\n    return function() {\n      return fn.apply(selfObj, arguments);\n    };\n  }\n};\n\n\n/**\n * Partially applies this function to a particular 'this object' and zero or\n * more arguments. The result is a new function with some arguments of the first\n * function pre-filled and the value of |this| 'pre-specified'.<br><br>\n *\n * Remaining arguments specified at call-time are appended to the pre-\n * specified ones.<br><br>\n *\n * Also see: {@link #partial}.<br><br>\n *\n * Usage:\n * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');\n * barMethBound('arg3', 'arg4');</pre>\n *\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @template T\n * @suppress {deprecated} See above.\n */\ngoog.bind = function(fn, selfObj, var_args) {\n  // TODO(nicksantos): narrow the type signature.\n  if (Function.prototype.bind &&\n      // NOTE(nicksantos): Somebody pulled base.js into the default\n      // Chrome extension environment. This means that for Chrome extensions,\n      // they get the implementation of Function.prototype.bind that\n      // calls goog.bind instead of the native one. Even worse, we don't want\n      // to introduce a circular dependency between goog.bind and\n      // Function.prototype.bind, so we have to hack this to make sure it\n      // works correctly.\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\n    goog.bind = goog.bindNative_;\n  } else {\n    goog.bind = goog.bindJs_;\n  }\n  return goog.bind.apply(null, arguments);\n};\n\n\n/**\n * Like bind(), except that a 'this object' is not required. Useful when the\n * target function is already bound.\n *\n * Usage:\n * var g = partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to fn.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n */\ngoog.partial = function(fn, var_args) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Prepend the bound arguments to the current arguments.\n    var newArgs = Array.prototype.slice.call(arguments);\n    newArgs.unshift.apply(newArgs, args);\n    return fn.apply(this, newArgs);\n  };\n};\n\n\n/**\n * Copies all the members of a source object to a target object. This method\n * does not work on all browsers for all objects that contain keys such as\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\n * @param {Object} target Target.\n * @param {Object} source Source.\n */\ngoog.mixin = function(target, source) {\n  for (var x in source) {\n    target[x] = source[x];\n  }\n\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\n  // not enumerable on the prototype object (for example, isPrototypeOf from\n  // Object.prototype) but also it will not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n};\n\n\n/**\n * @return {number} An integer value representing the number of milliseconds\n *     between midnight, January 1, 1970 and the current time.\n */\ngoog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\n  // Unary plus operator converts its operand to a number which in the case of\n  // a date is done by calling getTime().\n  return +new Date();\n});\n\n\n/**\n * Evals javascript in the global scope.  In IE this uses execScript, other\n * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\n * global scope (for example, in Safari), appends a script tag instead.\n * Throws an exception if neither execScript or eval is defined.\n * @param {string} script JavaScript string.\n */\ngoog.globalEval = function(script) {\n  if (goog.global.execScript) {\n    goog.global.execScript(script, 'JavaScript');\n  } else if (goog.global.eval) {\n    // Test to see if eval works\n    if (goog.evalWorksForGlobals_ == null) {\n      goog.global.eval('var _et_ = 1;');\n      if (typeof goog.global['_et_'] != 'undefined') {\n        delete goog.global['_et_'];\n        goog.evalWorksForGlobals_ = true;\n      } else {\n        goog.evalWorksForGlobals_ = false;\n      }\n    }\n\n    if (goog.evalWorksForGlobals_) {\n      goog.global.eval(script);\n    } else {\n      var doc = goog.global.document;\n      var scriptElt = doc.createElement('script');\n      scriptElt.type = 'text/javascript';\n      scriptElt.defer = false;\n      // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\n      // .text doesn't work in Safari 2.  Therefore we append a text node.\n      scriptElt.appendChild(doc.createTextNode(script));\n      doc.body.appendChild(scriptElt);\n      doc.body.removeChild(scriptElt);\n    }\n  } else {\n    throw Error('goog.globalEval not available');\n  }\n};\n\n\n/**\n * Indicates whether or not we can call 'eval' directly to eval code in the\n * global scope. Set to a Boolean by the first call to goog.globalEval (which\n * empirically tests whether eval works for globals). @see goog.globalEval\n * @type {?boolean}\n * @private\n */\ngoog.evalWorksForGlobals_ = null;\n\n\n/**\n * Optional map of CSS class names to obfuscated names used with\n * goog.getCssName().\n * @type {Object|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMapping_;\n\n\n/**\n * Optional obfuscation style for CSS class names. Should be set to either\n * 'BY_WHOLE' or 'BY_PART' if defined.\n * @type {string|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMappingStyle_;\n\n\n/**\n * Handles strings that are intended to be used as CSS class names.\n *\n * This function works in tandem with @see goog.setCssNameMapping.\n *\n * Without any mapping set, the arguments are simple joined with a\n * hyphen and passed through unaltered.\n *\n * When there is a mapping, there are two possible styles in which\n * these mappings are used. In the BY_PART style, each part (i.e. in\n * between hyphens) of the passed in css name is rewritten according\n * to the map. In the BY_WHOLE style, the full css name is looked up in\n * the map directly. If a rewrite is not specified by the map, the\n * compiler will output a warning.\n *\n * When the mapping is passed to the compiler, it will replace calls\n * to goog.getCssName with the strings from the mapping, e.g.\n *     var x = goog.getCssName('foo');\n *     var y = goog.getCssName(this.baseClass, 'active');\n *  becomes:\n *     var x= 'foo';\n *     var y = this.baseClass + '-active';\n *\n * If one argument is passed it will be processed, if two are passed\n * only the modifier will be processed, as it is assumed the first\n * argument was generated as a result of calling goog.getCssName.\n *\n * @param {string} className The class name.\n * @param {string=} opt_modifier A modifier to be appended to the class name.\n * @return {string} The class name or the concatenation of the class name and\n *     the modifier.\n */\ngoog.getCssName = function(className, opt_modifier) {\n  var getMapping = function(cssName) {\n    return goog.cssNameMapping_[cssName] || cssName;\n  };\n\n  var renameByParts = function(cssName) {\n    // Remap all the parts individually.\n    var parts = cssName.split('-');\n    var mapped = [];\n    for (var i = 0; i < parts.length; i++) {\n      mapped.push(getMapping(parts[i]));\n    }\n    return mapped.join('-');\n  };\n\n  var rename;\n  if (goog.cssNameMapping_) {\n    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?\n        getMapping : renameByParts;\n  } else {\n    rename = function(a) {\n      return a;\n    };\n  }\n\n  if (opt_modifier) {\n    return className + '-' + rename(opt_modifier);\n  } else {\n    return rename(className);\n  }\n};\n\n\n/**\n * Sets the map to check when returning a value from goog.getCssName(). Example:\n * <pre>\n * goog.setCssNameMapping({\n *   \"goog\": \"a\",\n *   \"disabled\": \"b\",\n * });\n *\n * var x = goog.getCssName('goog');\n * // The following evaluates to: \"a a-b\".\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\n * </pre>\n * When declared as a map of string literals to string literals, the JSCompiler\n * will replace all calls to goog.getCssName() using the supplied map if the\n * --closure_pass flag is set.\n *\n * @param {!Object} mapping A map of strings to strings where keys are possible\n *     arguments to goog.getCssName() and values are the corresponding values\n *     that should be returned.\n * @param {string=} opt_style The style of css name mapping. There are two valid\n *     options: 'BY_PART', and 'BY_WHOLE'.\n * @see goog.getCssName for a description.\n */\ngoog.setCssNameMapping = function(mapping, opt_style) {\n  goog.cssNameMapping_ = mapping;\n  goog.cssNameMappingStyle_ = opt_style;\n};\n\n\n/**\n * To use CSS renaming in compiled mode, one of the input files should have a\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\n * mode, JavaScript code should be loaded before this base.js file that declares\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\n * are made in uncompiled mode.\n *\n * A hook for overriding the CSS name mapping.\n * @type {Object|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\n\n\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\n  // This does not call goog.setCssNameMapping() because the JSCompiler\n  // requires that goog.setCssNameMapping() be called with an object literal.\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\n}\n\n\n/**\n * Gets a localized message.\n *\n * This function is a compiler primitive. If you give the compiler a localized\n * message bundle, it will replace the string at compile-time with a localized\n * version, and expand goog.getMsg call to a concatenated string.\n *\n * Messages must be initialized in the form:\n * <code>\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\n * </code>\n *\n * @param {string} str Translatable string, places holders in the form {$foo}.\n * @param {Object=} opt_values Map of place holder name to value.\n * @return {string} message with placeholders filled.\n */\ngoog.getMsg = function(str, opt_values) {\n  var values = opt_values || {};\n  for (var key in values) {\n    var value = ('' + values[key]).replace(/\\$/g, '$$$$');\n    str = str.replace(new RegExp('\\\\{\\\\$' + key + '\\\\}', 'gi'), value);\n  }\n  return str;\n};\n\n\n/**\n * Gets a localized message. If the message does not have a translation, gives a\n * fallback message.\n *\n * This is useful when introducing a new message that has not yet been\n * translated into all languages.\n *\n * This function is a compiler primtive. Must be used in the form:\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\n * where MSG_A and MSG_B were initialized with goog.getMsg.\n *\n * @param {string} a The preferred message.\n * @param {string} b The fallback message.\n * @return {string} The best translated message.\n */\ngoog.getMsgWithFallback = function(a, b) {\n  return a;\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated,\n * unless they are exported in turn via this function or\n * goog.exportProperty\n *\n * <p>Also handy for making public items that are defined in anonymous\n * closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction',\n *                       Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n */\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { }\n *\n * function ChildClass(a, b, c) {\n *   goog.base(this, a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // works\n * </pre>\n *\n * In addition, a superclass' implementation of a method can be invoked\n * as follows:\n *\n * <pre>\n * ChildClass.prototype.foo = function(a) {\n *   ChildClass.superClass_.foo.call(this, a);\n *   // other code\n * };\n * </pre>\n *\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {};\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n};\n\n\n/**\n * Call up to the superclass.\n *\n * If this is called from a constructor, then this calls the superclass\n * contructor with arguments 1-N.\n *\n * If this is called from a prototype method, then you must pass\n * the name of the method as the second argument to this function. If\n * you do not, you will get a runtime error. This calls the superclass'\n * method with arguments 2-N.\n *\n * This function only works if you use goog.inherits to express\n * inheritance relationships between your classes.\n *\n * This function is a compiler primitive. At compile-time, the\n * compiler will do macro expansion to remove a lot of\n * the extra overhead that this function introduces. The compiler\n * will also enforce a lot of the assumptions that this function\n * makes, and treat it as a compiler error if you break them.\n *\n * @param {!Object} me Should always be \"this\".\n * @param {*=} opt_methodName The method name if calling a super method.\n * @param {...*} var_args The rest of the arguments.\n * @return {*} The return value of the superclass method.\n */\ngoog.base = function(me, opt_methodName, var_args) {\n  var caller = arguments.callee.caller;\n  if (caller.superClass_) {\n    // This is a constructor. Call the superclass constructor.\n    return caller.superClass_.constructor.apply(\n        me, Array.prototype.slice.call(arguments, 1));\n  }\n\n  var args = Array.prototype.slice.call(arguments, 2);\n  var foundCaller = false;\n  for (var ctor = me.constructor;\n       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {\n    if (ctor.prototype[opt_methodName] === caller) {\n      foundCaller = true;\n    } else if (foundCaller) {\n      return ctor.prototype[opt_methodName].apply(me, args);\n    }\n  }\n\n  // If we did not find the caller in the prototype chain,\n  // then one of two things happened:\n  // 1) The caller is an instance method.\n  // 2) This method was not called by the right caller.\n  if (me[opt_methodName] === caller) {\n    return me.constructor.prototype[opt_methodName].apply(me, args);\n  } else {\n    throw Error(\n        'goog.base called from a method of one name ' +\n        'to a method of a different name');\n  }\n};\n\n\n/**\n * Allow for aliasing within scope functions.  This function exists for\n * uncompiled code - in compiled code the calls will be inlined and the\n * aliases applied.  In uncompiled code the function is simply run since the\n * aliases as written are valid JavaScript.\n * @param {function()} fn Function to call.  This function can contain aliases\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\n *    (e.g. \"var Timer = goog.Timer\").\n */\ngoog.scope = function(fn) {\n  fn.call(goog.global);\n};\n\n\n",
		"goog.provide('H.mapevents.Pointer');\n\n\n\n/**\n * Class representing pointer on the map surface. A pointer\n * in platform specific definition would mean either mouse,\n * touch, pen or any pointing device which can trigger browser events.\n *\n * @constructor\n * @param {number} viewportX pointer position on x-axis\n * @param {number} viewportY pointer position on y-axis\n * @param {number} id unique pointer identifier among currently available pointers\n * @param {string} type type of pointer can be i.e 'mouse', 'touch'. 'pen'\n *\n * @publish\n * @export\n */\nH.mapevents.Pointer = function(viewportX, viewportY, id, type) {\n  'use strict';\n\n  if (isNaN(viewportX)) {\n    throw new Error('x needs to be a number');\n  }\n\n  if (isNaN(viewportY)) {\n    throw new Error('y needs to be a number');\n  }\n\n  if (isNaN(id)) {\n    throw new Error('pointer must have an id');\n  }\n\n  /**\n   * X coordinate on the map's viewport\n   * @type {number}\n   * @name H.mapevents.Pointer.viewportX\n   * @publish\n   */\n  this['viewportX'] = viewportX;\n\n  /**\n   * Y coordinate on the map's viewport\n   * @type {number}\n   * @name H.mapevents.Pointer.viewportY\n   * @publish\n   */\n  this['viewportY'] = viewportY;\n\n  /**\n   * Map object directly under the pointer. Can be null if if pointer is out of the\n   * map viewport\n   * @type {H.map.Object|H.Map}\n   * @name H.mapevents.Pointer.target\n   * @publish\n   */\n  this['target'] = null;\n\n  /**\n   * Pointer unique identifier.\n   * @type {number}\n   * @name H.mapevents.Pointer.id\n   * @publish\n   */\n  this['id'] = id;\n\n  /**\n   * Pointer type can be: 'mouse', 'touch' or 'pen'\n   * @type {string}\n   * @name H.mapevents.Pointer.type\n   * @publish\n   */\n  this['type'] = type;\n\n  /**\n   * Object which is currently dragged by the pointer\n   * @type {H.map.Object|H.Map}\n   * @name H.mapevents.Pointer.dragTarget\n   * @publish\n   */\n  this['dragTarget'] = null;\n};\n\n\n/**\n * Update pointer map position.\n * @param {number} x\n * @param {number} y\n */\nH.mapevents.Pointer.prototype.updatePosition = function(x, y) {\n  'use strict';\n\n  if (isNaN(x)) {\n    throw new Error('x needs to be a number');\n  }\n\n  if (isNaN(y)) {\n    throw new Error('y needs to be a number');\n  }\n\n  this['viewportX'] = x;\n  this['viewportY'] = y;\n};\n\n\n/**\n * Updates pointer's target\n * @param {*} target\n */\nH.mapevents.Pointer.prototype.setTarget = function(target) {\n  'use strict';\n  this['target'] = target;\n};\n\n\n/**\n * Updates pointer dragging target\n * @param {*} dragTarget\n */\nH.mapevents.Pointer.prototype.setDragTarget = function(dragTarget) {\n  'use strict';\n  this['dragTarget'] = dragTarget;\n};\n\n\n",
		"/**\n * Namespace represents utilities used by the mapevents extension\n * @namespace\n */\ngoog.provide('H.mapevents.util');\n\n\n/**\n * Returns element offset from document top left corner.\n * @param {HTMLElement} element\n * @return {H.math.IPoint}\n */\nH.mapevents.util.findOffset = function(element) {\n  'use strict';\n  var doc = element.ownerDocument,\n      docElement = doc.documentElement || doc.body.parentNode || doc.body,\n      clientRect;\n\n  clientRect = element.getBoundingClientRect();\n  return /** @type {H.math.IPoint} */ ({\n    'x': clientRect['left'] + (typeof(window.pageXOffset) === 'number' ? window.pageXOffset : docElement.scrollLeft),\n    'y': clientRect['top'] + (typeof(window.pageYOffset) === 'number' ? window.pageYOffset : docElement.scrollTop)\n  });\n};\n\n",
		"goog.provide('H.mapevents.Event');\n\n\n\n/**\n * Custom map event. Contains list of pointers on the map, list of changed pointers\n * and original event. Inherits from H.util.Event.\n *\n * @constructor\n * @extends {H.util.Event}\n *\n *\n * @param {string} type type of event\n * @param {Array.<H.mapevents.Pointer>} pointers pointers which are currently on the screen\n * @param {Array.<H.mapevents.Pointer>} changedPointers pointers which changed during event\n * @param {Array.<H.mapevents.Pointer>} targetPointers pointers on the event target\n * @param {H.mapevents.Pointer} currentPointer pointer which triggered the event\n * @param {H.Map|H.map.Object} target target map object which triggered event\n * @param {Event} originalEvent original dom event\n *\n * @publish\n * @export\n */\nH.mapevents.Event = function(type, pointers, changedPointers,\n    targetPointers, currentPointer, target, originalEvent) {\n  'use strict';\n  H.util.getSuperProto(H.mapevents.Event).constructor.call(this, type);\n\n  /**\n   * Pointers which are currently on the screen\n   * @type {Array.<H.mapevents.Pointer>}\n   * @name H.mapevents.Event#pointers\n   * @publish\n   */\n  this['pointers'] = pointers;\n\n  /**\n   * Pointers which has changed in course of event\n   * @type {Array.<H.mapevents.Pointer>}\n   * @name H.mapevents.Event#changedPointers\n   * @publish\n   */\n  this['changedPointers'] = changedPointers;\n\n  /**\n   * Pointers which are on same target as the current pointer\n   * @type {Array.<H.mapevents.Pointer>}\n   * @name H.mapevents.Event#targetPointers\n   * @publish\n   */\n  this['targetPointers'] = targetPointers;\n\n  /**\n   * Current pointer\n   * @type {H.mapevents.Pointer}\n   * @name H.mapevents.Event#currentPointer\n   * @publish\n   */\n  this['currentPointer'] = currentPointer;\n\n\n  /**\n   * Original event fired by the browser\n   * @type {Event}\n   * @name H.mapevents.Event#originalEvent\n   * @publish\n   */\n  this['originalEvent'] = originalEvent;\n\n  /**\n   * Object which triggered event. Can be the map object (i.e marker or polyline)\n   * or the map itself\n   * @type {H.map.Object|H.Map}\n   * @name H.mapevents.Event#target\n   * @publish\n   */\n  this['target'] = target;\n\n};\nH.lang.inherits(H.mapevents.Event, H.util.Event);\n\n/**\n * Object which has listener attached\n * @publish\n * @type {H.map.Object|H.Map}\n * @name H.util.Event#currentTarget\n */\n\n/**\n * Name of the dispatched event\n * @publish\n * @type {string}\n * @name H.util.Event#type\n */\n\n/**\n * Indicates if preventDefault was called on the current event\n * @publish\n * @type {boolean}\n * @name H.util.Event#defaultPrevented\n */\n\n/**\n * Sets defaultPrevented to true. Which can be used to prevent\n * some default behavior.\n * @publish\n * @function\n * @name H.util.Event#preventDefault\n */\n\n/**\n * Stops propagation for current event.\n * @function\n * @name H.util.Event#stopPropagation\n * @export\n * @publish\n */\n\n",
		"goog.provide('H.mapevents.PointerList');\n\ngoog.require('H.mapevents.Pointer');\n\n\n\n/**\n * Class represents a list of pointers with some convinience methods\n * used by the handlers to sort out the map pointer events. This class is\n * used internally by the handlers.\n * @param {Array=} opt_pointers\n * @constructor\n */\nH.mapevents.PointerList = function(opt_pointers) {\n  'use strict';\n  /**\n   * @private\n   */\n  this.list_ = (opt_pointers instanceof Array) ? opt_pointers.slice(0) : [];\n};\n\n\n/**\n * Removes all pointers from the list\n */\nH.mapevents.PointerList.prototype.clear = function() {\n  'use strict';\n  this.list_.splice(0, this.list_.length);\n};\n\n\n/**\n * Returns lengths of the list.\n * @return {number}\n */\nH.mapevents.PointerList.prototype.length = function() {\n  'use strict';\n  return this.list_.length;\n};\n\n\n/**\n * Returns element on the give index position\n * @param {number} idx\n * @return {H.mapevents.Pointer} pointer\n */\nH.mapevents.PointerList.prototype.item = function(idx) {\n  'use strict';\n  return this.list_[idx];\n};\n\n\n/**\n * Returns position of the pointer for given pointerID\n * @param {number} pointerId\n * @return {number} position of the pointer which ahs given ID  or -1;\n */\nH.mapevents.PointerList.prototype.indexOf = function(pointerId) {\n  'use strict';\n  var i = this.list_.length;\n  while (i--) {\n    if (this.list_[i]['id'] === pointerId) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n\n/**\n * Returns pointer fetched from the list by ID or null if there is not any\n * @param {number} pointerId\n * @return {H.mapevents.Pointer} pointer which has been found by given id (or null)\n */\nH.mapevents.PointerList.prototype.byId = function(pointerId) {\n  'use strict';\n  var idx = this.indexOf(pointerId);\n  return idx !== -1 ? this.list_[idx] : null;\n};\n\n\n/**\n * Removes pointer with given identifier from the list.\n * @param {number} pointerId id of the pointer\n * @return {H.mapevents.Pointer?} removed pointer or null in case it was not found\n */\nH.mapevents.PointerList.prototype.remove = function(pointerId) {\n  'use strict';\n  var idx = this.indexOf(pointerId);\n  if (idx !== -1) {\n    return this.list_.splice(idx, 1)[0];\n  }\n  return null;\n};\n\n\n/**\n * This method removes pointer of given type from the list.\n * @param {string} type type of pointer i.e 'mouse', 'touch', 'pen'\n */\nH.mapevents.PointerList.prototype.removeByType = function(type) {\n  'use strict';\n  var i = this.list_.length,\n      list = [];\n\n  while (i--) {\n    if (this.list_[i]['type'] !== type) {\n      list.push(this.list_[i]);\n    }\n  }\n\n  this.list_ = list;\n};\n\n\n/**\n * Thie methos returns an array of pointers which are on the given target.\n * @param {*} target\n * @return {Array.<H.mapevents.Pointer>}\n */\nH.mapevents.PointerList.prototype.getOnTarget = function(target) {\n  'use strict';\n  var i,\n      l = this.list_.length,\n      onTarget = [];\n  for (i = 0; i < l; i++) {\n    if (this.list_[i]['target'] === target) {\n      onTarget.push(this.list_[i]);\n    }\n  }\n\n  return onTarget;\n};\n\n\n/**\n * This method returns true if object is dragged by one\n * of the pointers in the list\n * @param {H.map.Object|H.Map} obj\n * @return {boolean}\n */\nH.mapevents.PointerList.prototype.isDragTarget = function(obj) {\n  'use strict';\n  var i = this.list_.length;\n  while (i--) {\n    if (this.list_[i]['dragTarget'] === obj) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Adds pointer to the list\n * @param {H.mapevents.Pointer} pointer\n * @return {number}\n */\nH.mapevents.PointerList.prototype.push = function(pointer) {\n  'use strict';\n  if (pointer instanceof H.mapevents.Pointer) {\n    return this.list_.push(pointer);\n  } else {\n    throw new Error('list needs a pointer');\n  }\n};\n\n\n/**\n * Returns pointers as array\n * @return {Array.<H.mapevents.Pointer>}\n */\nH.mapevents.PointerList.prototype.asArray = function() {\n  'use strict';\n  return this.list_;\n};\n\n\n/**\n * Clones the list\n * @return {H.mapevents.PointerList}\n */\nH.mapevents.PointerList.prototype.clone = function() {\n  'use strict';\n  return new H.mapevents.PointerList(this.list_);\n};\n\n\n\n\n",
		"// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Implements the disposable interface. The dispose method is used\n * to clean up references and resources.\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\ngoog.provide('goog.Disposable');\ngoog.provide('goog.dispose');\n\ngoog.require('goog.disposable.IDisposable');\n\n\n\n/**\n * Class that provides the basic implementation for disposable objects. If your\n * class holds one or more references to COM objects, DOM nodes, or other\n * disposable objects, it should extend this class or implement the disposable\n * interface (defined in goog.disposable.IDisposable).\n * @constructor\n * @implements {goog.disposable.IDisposable}\n */\ngoog.Disposable = function() {\n  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\n    this.creationStack = new Error().stack;\n    goog.Disposable.instances_[goog.getUid(this)] = this;\n  }\n};\n\n\n/**\n * @enum {number} Different monitoring modes for Disposable.\n */\ngoog.Disposable.MonitoringMode = {\n  /**\n   * No monitoring.\n   */\n  OFF: 0,\n  /**\n   * Creating and disposing the goog.Disposable instances is monitored. All\n   * disposable objects need to call the {@code goog.Disposable} base\n   * constructor. The PERMANENT mode must bet switched on before creating any\n   * goog.Disposable instances.\n   */\n  PERMANENT: 1,\n  /**\n   * INTERACTIVE mode can be switched on and off on the fly without producing\n   * errors. It also doesn't warn if the disposable objects don't call the\n   * {@code goog.Disposable} base constructor.\n   */\n  INTERACTIVE: 2\n};\n\n\n/**\n * @define {number} The monitoring mode of the goog.Disposable\n *     instances. Default is OFF. Switching on the monitoring is only\n *     recommended for debugging because it has a significant impact on\n *     performance and memory usage. If switched off, the monitoring code\n *     compiles down to 0 bytes.\n */\ngoog.Disposable.MONITORING_MODE = 0;\n\n\n/**\n * Maps the unique ID of every undisposed {@code goog.Disposable} object to\n * the object itself.\n * @type {!Object.<number, !goog.Disposable>}\n * @private\n */\ngoog.Disposable.instances_ = {};\n\n\n/**\n * @return {!Array.<!goog.Disposable>} All {@code goog.Disposable} objects that\n *     haven't been disposed of.\n */\ngoog.Disposable.getUndisposedObjects = function() {\n  var ret = [];\n  for (var id in goog.Disposable.instances_) {\n    if (goog.Disposable.instances_.hasOwnProperty(id)) {\n      ret.push(goog.Disposable.instances_[Number(id)]);\n    }\n  }\n  return ret;\n};\n\n\n/**\n * Clears the registry of undisposed objects but doesn't dispose of them.\n */\ngoog.Disposable.clearUndisposedObjects = function() {\n  goog.Disposable.instances_ = {};\n};\n\n\n/**\n * Whether the object has been disposed of.\n * @type {boolean}\n * @private\n */\ngoog.Disposable.prototype.disposed_ = false;\n\n\n/**\n * Callbacks to invoke when this object is disposed.\n * @type {Array.<!Function>}\n * @private\n */\ngoog.Disposable.prototype.onDisposeCallbacks_;\n\n\n/**\n * If monitoring the goog.Disposable instances is enabled, stores the creation\n * stack trace of the Disposable instance.\n * @type {string}\n */\ngoog.Disposable.prototype.creationStack;\n\n\n/**\n * @return {boolean} Whether the object has been disposed of.\n * @override\n */\ngoog.Disposable.prototype.isDisposed = function() {\n  return this.disposed_;\n};\n\n\n/**\n * @return {boolean} Whether the object has been disposed of.\n * @deprecated Use {@link #isDisposed} instead.\n */\ngoog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;\n\n\n/**\n * Disposes of the object. If the object hasn't already been disposed of, calls\n * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should\n * override {@link #disposeInternal} in order to delete references to COM\n * objects, DOM nodes, and other disposable objects. Reentrant.\n *\n * @return {void} Nothing.\n * @override\n */\ngoog.Disposable.prototype.dispose = function() {\n  if (!this.disposed_) {\n    // Set disposed_ to true first, in case during the chain of disposal this\n    // gets disposed recursively.\n    this.disposed_ = true;\n    this.disposeInternal();\n    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\n      var uid = goog.getUid(this);\n      if (goog.Disposable.MONITORING_MODE ==\n          goog.Disposable.MonitoringMode.PERMANENT &&\n          !goog.Disposable.instances_.hasOwnProperty(uid)) {\n        throw Error(this + ' did not call the goog.Disposable base ' +\n            'constructor or was disposed of after a clearUndisposedObjects ' +\n            'call');\n      }\n      delete goog.Disposable.instances_[uid];\n    }\n  }\n};\n\n\n/**\n * Associates a disposable object with this object so that they will be disposed\n * together.\n * @param {goog.disposable.IDisposable} disposable that will be disposed when\n *     this object is disposed.\n */\ngoog.Disposable.prototype.registerDisposable = function(disposable) {\n  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));\n};\n\n\n/**\n * Invokes a callback function when this object is disposed. Callbacks are\n * invoked in the order in which they were added.\n * @param {function(this:T):?} callback The callback function.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @template T\n */\ngoog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {\n  if (!this.onDisposeCallbacks_) {\n    this.onDisposeCallbacks_ = [];\n  }\n  this.onDisposeCallbacks_.push(goog.bind(callback, opt_scope));\n};\n\n\n/**\n * Deletes or nulls out any references to COM objects, DOM nodes, or other\n * disposable objects. Classes that extend {@code goog.Disposable} should\n * override this method.\n * Not reentrant. To avoid calling it twice, it must only be called from the\n * subclass' {@code disposeInternal} method. Everywhere else the public\n * {@code dispose} method must be used.\n * For example:\n * <pre>\n *   mypackage.MyClass = function() {\n *     goog.base(this);\n *     // Constructor logic specific to MyClass.\n *     ...\n *   };\n *   goog.inherits(mypackage.MyClass, goog.Disposable);\n *\n *   mypackage.MyClass.prototype.disposeInternal = function() {\n *     // Dispose logic specific to MyClass.\n *     ...\n *     // Call superclass's disposeInternal at the end of the subclass's, like\n *     // in C++, to avoid hard-to-catch issues.\n *     goog.base(this, 'disposeInternal');\n *   };\n * </pre>\n * @protected\n */\ngoog.Disposable.prototype.disposeInternal = function() {\n  if (this.onDisposeCallbacks_) {\n    while (this.onDisposeCallbacks_.length) {\n      this.onDisposeCallbacks_.shift()();\n    }\n  }\n};\n\n\n/**\n * Returns True if we can verify the object is disposed.\n * Calls {@code isDisposed} on the argument if it supports it.  If obj\n * is not an object with an isDisposed() method, return false.\n * @param {*} obj The object to investigate.\n * @return {boolean} True if we can verify the object is disposed.\n */\ngoog.Disposable.isDisposed = function(obj) {\n  if (obj && typeof obj.isDisposed == 'function') {\n    return obj.isDisposed();\n  }\n  return false;\n};\n\n\n/**\n * Calls {@code dispose} on the argument if it supports it. If obj is not an\n *     object with a dispose() method, this is a no-op.\n * @param {*} obj The object to dispose of.\n */\ngoog.dispose = function(obj) {\n  if (obj && typeof obj.dispose == 'function') {\n    obj.dispose();\n  }\n};\n\n\n/**\n * Calls {@code dispose} on each member of the list that supports it. (If the\n * member is an ArrayLike, then {@code goog.disposeAll()} will be called\n * recursively on each of its members.) If the member is not an object with a\n * {@code dispose()} method, then it is ignored.\n * @param {...*} var_args The list.\n */\ngoog.disposeAll = function(var_args) {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    var disposable = arguments[i];\n    if (goog.isArrayLike(disposable)) {\n      goog.disposeAll.apply(null, disposable);\n    } else {\n      goog.dispose(disposable);\n    }\n  }\n};\n",
		"goog.provide('H.mapevents.handlers.Handler');\n\ngoog.require('goog.Disposable');\ngoog.require('H.mapevents.Event');\ngoog.require('H.mapevents.Pointer');\ngoog.require('H.mapevents.PointerList');\ngoog.require('H.mapevents.util');\n\n\n\n/**\n * Handler class. Is responsible for firing events on objects and the map.\n * Holds common functionality for all handlers like attaching event listeners etc.\n * Resolves click, tap and dbclik and dbltap and dragging depending on thresholds\n * and events.\n * @constructor\n * @extends {goog.Disposable}\n *\n * @param {H.Map} map instance\n * @param {Array.<H.mapevents.handlers.Handler.Map>} eventsMap\n * @param {H.mapevents.handlers.Handler.Options=} opt_options\n */\nH.mapevents.handlers.Handler = function(map, eventsMap, opt_options) {\n  'use strict';\n  var options = opt_options || {};\n\n  if (!(map instanceof H.Map)) {\n    throw new Error('events: map instance required');\n  }\n\n  if (!(eventsMap instanceof Array)) {\n    throw new Error('events: map array required');\n  }\n\n  goog.Disposable.call(this);\n\n  /**\n   * @type {number}\n   * @protected\n   */\n  this.dblTapThreshold = options.dblTapThreshold || 500;\n\n  /**\n   * @type {number}\n   * @protected\n   */\n  this.dblTapDistanceThreshold = options.dblTapDistanceThreshold || 50;\n\n  /**\n   * @type {number}\n   * @protected\n   */\n  this.tapDistanceThreshold = options.tapDistanceThreshold || 50;\n\n  /**\n   * @type {number}\n   * @protected\n   */\n  this.tapThreshold = options.tapThreshold || 500;\n\n  /**\n   * Time after which longpress is dispatched, unless interrupted by other event like poitnerup\n   * @type {number}\n   * @protected\n   */\n  this.longPressThreshold = options.longPressThreshold || 1000;\n\n  /**\n   * If pointer during pointerdown move away from the starting point more\n   * than diameter of distance threshold longpress will not be fired\n   * @type {number}\n   * @protected\n   */\n  this.longPressDistanceThreshold = options.longPressDistanceThreshold || 50;\n\n  /**\n   * @type {H.Map}\n   * @protected\n   */\n  this.map = map;\n\n  /**\n   * @private\n   */\n  this.viewPort_ = this.map.getViewPort();\n\n  /**\n   * Element to which listeners are attached by default, unless it\n   * is specified differently by the listeners map\n   * @type {HTMLElement}\n   * @protected\n   */\n  this.element = this.viewPort_['element'];\n\n  /**\n   * Currently set listeners map for addin removing nativve event\n   * listeners\n   * @private\n   */\n  this.eventsMap_ = eventsMap;\n\n  /**\n   * List of currently existing pointers on map\n   * @type {H.mapevents.PointerList}\n   * @protected\n   */\n  this.pointers = new H.mapevents.PointerList();\n\n  /**\n   * List of currently changed pointers on map.\n   * @type {H.mapevents.PointerList}\n   * @protected\n   */\n  this.changedPointers = new H.mapevents.PointerList();\n\n  /**\n   * Map which stores last pointerdown by pointer id, used for\n   * click/tap calculation\n   * @type {Object}\n   * @private\n   */\n  this.lastPointerDown_ = {};\n\n  /**\n   * Currently dragging pointer (pointer id)\n   * @type {H.mapevents.Pointer}\n   * @private\n   */\n  this.dragging_ = null;\n\n  /**\n   * Flag used to omit the firs move event for mouse\n   * @private\n   */\n  this.firstDragMove_ = true;\n\n  /**\n   * Map of next scheduled drag timeout reference by pointer id.\n   * @type {Object}\n   * @private\n   */\n  this.nextDrag_ = {};\n\n  /**\n   * Map of potential longpresses\n   * @type {Object}\n   * @private\n   */\n  this.longPress_ = {};\n\n  /**\n   * last dispatched event name\n   * @private\n   */\n  this.lastDispatchedName_ = null;\n\n  /**\n   * last dispached tap information. Object contains timestamp and tap target\n   * @private\n   */\n  this.lastTapped_ = null;\n\n  /**\n   * @private\n   */\n  this.createOngoingDrag_ = H.lang.bind(this.createOngoingDrag_, this);\n\n  /**\n   * @private\n   */\n  this.eventDispatcher_ = {\n    'pointerdown': this.dispatchpointerdown,\n    'pointermove': this.dispatchpointermove,\n    'pointerup': this.dispatchpointerup,\n    'pointercancel': this.dispatchpointercancel\n  };\n\n  this.addRemoveListeners_();\n};\nH.lang.inherits(H.mapevents.handlers.Handler, goog.Disposable);\n\n\n/**\n * This value represents the time for countinous drag timestamp\n * TODO: FIXME (some setting or configuration ?)\n * @private\n */\nH.mapevents.handlers.Handler.CONTINUE_DRAG_TIME_ = 150;\n\n\n/**\n * Function attaches listeners from the eventsMap\n * @param {boolean=} opt_remove if set to tru it will remove the listeners instead of attaching\n * @private\n */\nH.mapevents.handlers.Handler.prototype.addRemoveListeners_ = function(opt_remove) {\n  'use strict';\n  var listener,\n      handler,\n      i = 0,\n      l = this.eventsMap_.length;\n\n  for (i = 0; i < l; i++) {\n    handler = this.eventsMap_[i];\n    listener = handler.listener;\n    if (typeof(listener) === 'function') {\n      if (opt_remove) {\n        (handler.target || this.element).removeEventListener(handler.eventName, listener);\n      } else {\n        (handler.target || this.element).addEventListener(handler.eventName, listener);\n      }\n    }\n  }\n};\n\n\n/**\n * This method dispatches custom pointer events. Every map object covered by the pointers\n * from changedPointers list will receive event. Before calling this function you should\n * prepare changedPointers and pointers list in advance. The changedPointers list will\n * be cleared by this function.\n *\n * @param {string} name pointer event name can be:\n * 'pointerdown', 'pointerup', 'pointermove', 'pointercancel'\n * @param {Event} originalEvt original event which was fired by the browser which will be\n * included in the cutom internal pointer event as a member variable\n *\n * @protected\n */\nH.mapevents.handlers.Handler.prototype.processPointerEvent = function(name, originalEvt) {\n  'use strict';\n  var dispatchHandler = 'dispatch' + name,\n      pointer,\n      pointerTarget,\n      dispatchFunc = this.eventDispatcher_[name],\n      i, l;\n\n  if (typeof(dispatchFunc) === 'function') {\n    if (name !== 'pointermove') {\n      //if not move reset first drag delay flag\n      this.firstDragMove_ = true;\n    }\n\n    //dispatch event for all prepared (changed) pointers\n    for (i = 0, l = this.changedPointers.length(); i < l; i++) {\n      pointer = this.changedPointers.item(i);\n      pointerTarget = this.element.contains(originalEvt['target']) ? this.getPointerTarget(pointer) : null;\n      //clear ongoing scheduled drags if any will be reinitiated by move in necessary\n      this.cancelScheduled_(pointer['id'], this.nextDrag_);\n      dispatchFunc.call(this, pointer, pointerTarget, originalEvt);\n    }\n\n    this.lastDispatchedName_ = name;\n  }\n\n  //clear the list so it can be filled again by the platform handler\n  this.changedPointers.clear();\n};\n\n\n/**\n * This method returns target map object for current pointer. It will return null\n * if the pointer is out of the maps viewport\n *\n * @param {H.mapevents.Pointer} pointer\n * @return {H.map.Object|H.Map|null}\n */\nH.mapevents.handlers.Handler.prototype.getPointerTarget = function(pointer) {\n  'use strict';\n  //TODO solve the dragging enter elave problem\n  if (this.dragging_ === pointer) {\n    return pointer['target'];\n  } else if (pointer['viewportX'] >= 0 && pointer['viewportX'] < this.viewPort_['width'] &&\n      pointer['viewportY'] >= 0 && pointer['viewportY'] < this.viewPort_['height']) {\n    return this.map.getObjectAt(pointer['viewportX'], pointer['viewportY']) || this.map;\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * Handles 'pointerup' event and triggers custom map 'pointerup' event on object or map\n * also handles dragend, and click dbclik (same for tap). It also resolves clik dblclick\n * tap and dbltap events.\n * @param {H.mapevents.Pointer} pointer\n * @param {H.Map|H.map.Object} pointerTarget\n * @param {Event} originalEvt\n */\nH.mapevents.handlers.Handler.prototype.dispatchpointerup = function(pointer, pointerTarget, originalEvt) {\n  'use strict';\n  var currentTimeStamp = originalEvt['timeStamp'],\n      lastTapped_ = this.lastTapped_,\n      evtName;\n\n  pointer.setTarget(pointerTarget);\n  this.resolveDragEnd_(pointer, originalEvt);\n  this.dispatchOnObject(pointerTarget, 'pointerup', originalEvt, pointer);\n  if (pointer['type'] !== 'mouse') {\n    this.dispatchOnObject(pointerTarget, 'pointerleave', originalEvt, pointer, true);\n  }\n\n  this.resolveTap_(pointer, originalEvt);\n  this.lastPointerDown_ = {};\n  this.cancelScheduled_(pointer['id'], this.longPress_);\n};\n\n\n/**\n * This method resolves and fires dragend event.\n * @param {H.mapevents.Pointer} pointer\n * @param {Event} originalEvt\n * @private\n */\nH.mapevents.handlers.Handler.prototype.resolveDragEnd_ = function(pointer, originalEvt) {\n  'use strict';\n  //check if the pointer was really dragging and do dragend\n  if (pointer === this.dragging_) {\n    this.dispatchOnObject(pointer['dragTarget'], 'dragend', originalEvt, pointer);\n    this.dragging_ = null;\n    this.cancelScheduled_(pointer['id'], this.nextDrag_);\n  }\n  //null drag target\n  pointer.setDragTarget(null);\n  //else do nothing the pointer;s target is not dragged\n};\n\n\n/**\n * This method resolves tap click and dbltap dblclick functionality. The events are fired on\n * the pointer target map object.\n * depending on pointerdown and pointerup sequence and thresholds.\n * @param {H.mapevents.Pointer} pointer\n * @param {Event} originalEvt\n * @private\n */\nH.mapevents.handlers.Handler.prototype.resolveTap_ = function(pointer, originalEvt) {\n  'use strict';\n  var lastPointerDown = this.lastPointerDown_[pointer['id']],\n      currentPos = {\n        'x': pointer['viewportX'],\n        'y': pointer['viewportY']\n      },\n      currentTimeStamp = originalEvt['timeStamp'],\n      pointerTarget = pointer['target'],\n      lastTapped_ = this.lastTapped_,\n      evtName;\n\n  if (lastPointerDown && lastPointerDown['target'] === pointerTarget &&\n      lastPointerDown.at.distance(currentPos) < this.tapDistanceThreshold &&\n      (currentTimeStamp - lastPointerDown.ts) < this.tapThreshold) {\n    evtName = 'tap';\n    this.dispatchOnObject(pointerTarget, evtName, originalEvt, pointer);\n    //check if target was tapped already (perhaps dbltap ?)\n    //check against threshold and distance from first tap/click\n    if (lastTapped_ && lastTapped_.target === pointerTarget && (\n        currentTimeStamp - lastTapped_.ts) < this.dblTapThreshold) {\n      //needs to be in separate condition closure compiler failed pretty printed for some reason\n      if (lastTapped_.at.distance({\n        'x': pointer['viewportX'],\n        'y': pointer['viewportY']\n      }) < this.dblTapDistanceThreshold) {\n        //dbltap/dblclik\n        this.dispatchOnObject(pointerTarget, 'dbl' + evtName, originalEvt, pointer);\n        this.lastTapped_ = null;\n      }\n    } else {\n      this.lastTapped_ = {\n        target: pointerTarget,\n        at: new H.math.Point(pointer['viewportX'], pointer['viewportY']),\n        ts: originalEvt['timeStamp']\n      };\n    }\n  } else {\n    this.lastTapped_ = null;\n  }\n\n};\n\n\n/**\n * This method fires continous drag events when no native\n * move is fired and user did not end the drag operation\n * @param {H.mapevents.Pointer} pointer\n * @param {Event} originalEvt\n * @private\n */\nH.mapevents.handlers.Handler.prototype.createOngoingDrag_ = function(pointer, originalEvt) {\n  'use strict';\n  var evt,\n      that = this;\n  evt = this.dispatchOnObject(pointer['dragTarget'], 'drag', originalEvt, pointer);\n  this.cancelScheduled_(pointer['id'], this.nextDrag_); //cancel previous if exists\n  this.nextDrag_[pointer['id']] = setTimeout(function() {\n    that.createOngoingDrag_(pointer, originalEvt);\n  }, H.mapevents.handlers.Handler.CONTINUE_DRAG_TIME_);\n};\n\n\n/**\n * This method cancels scheduled task from the task map\n * @param {string|number} pointerId\n * @param {Object} scheduleMap map which contain scheduled references\n * @private\n */\nH.mapevents.handlers.Handler.prototype.cancelScheduled_ = function(pointerId, scheduleMap) {\n  'use strict';\n  if (scheduleMap[pointerId]) {\n    clearTimeout(scheduleMap[pointerId]);\n    delete scheduleMap[pointerId];\n  }\n};\n\n\n/**\n * This method clears all scheduled tasks for the provided map\n * @param {Object} scheduleMap scheduled task handlers\n * @private\n */\nH.mapevents.handlers.Handler.prototype.clearAllScheduled_ = function(scheduleMap) {\n  'use strict';\n  for (var pointerId in scheduleMap) {\n    this.cancelScheduled_(pointerId, scheduleMap);\n  }\n};\n\n\n/**\n * This method setups potential longpress which can be resolved\n * @param {H.mapevents.Pointer} pointer\n * @param {Event} originalEvent\n * @private\n */\nH.mapevents.handlers.Handler.prototype.setupLongpress_ = function(pointer, originalEvent) {\n  'use strict';\n  var lastDownTarget = pointer['target'],\n      startPoint = new H.math.Point(pointer['viewportX'], pointer['viewportY']),\n      pointerId = pointer['id'],\n      that = this;\n\n  this.cancelScheduled_(pointerId, this.longPress_);\n  this.longPress_[pointerId] = setTimeout(function() {\n    if (lastDownTarget && lastDownTarget === pointer['target'] &&\n        startPoint.distance( /** @type {H.math.IPoint} */ ({\n          'x': pointer['viewportX'],\n          'y': pointer['viewportY']\n        })) < that.longPressDistanceThreshold) {\n      that.dispatchOnObject(lastDownTarget, 'longpress', originalEvent, pointer);\n      delete that.lastPointerDown_[pointer['id']];\n    }\n  }, this.longPressThreshold);\n};\n\n\n/**\n * Triggers pointermove event on the pointer target. It resolves and triggers pointerenter and pointerleave\n * events depending on comparison of the current and new pointer targets.  It also resolves dragstart event\n * if target is draggable and as well as drag events\n * @param {H.mapevents.Pointer} pointer pointer to which action is bound\n * @param {H.Map|H.map.Object} pointerTarget the target which is uder the pointer\n * @param {Event} originalEvt original event which is passed to custom event\n *\n */\nH.mapevents.handlers.Handler.prototype.dispatchpointermove = function(pointer, pointerTarget, originalEvt) {\n  'use strict';\n  //console.log(originalEvt);\n  var dragTarget = pointer['dragTarget'],\n      pointerId = pointer['id'],\n      prevTarget;\n\n  prevTarget = pointer['target'];\n  pointer.setTarget(pointerTarget);\n  if (prevTarget !== pointerTarget) {\n    this.dispatchOnObject(prevTarget, 'pointerleave', originalEvt, pointer, true);\n    this.dispatchOnObject(pointerTarget, 'pointerenter', originalEvt, pointer, true);\n  }\n\n  if (!dragTarget) {\n    if (!this.dragging_ || (this.dragging_ && this.dragging_['dragTarget'] !== pointerTarget &&\n        this.dragging_['dragTarget'] !== this.map)) {\n      this.dispatchOnObject(pointerTarget, 'pointermove', originalEvt, pointer);\n    }\n  } else {\n    if (!this.dragging_) {\n      //set this pointers as currently dragging pointer\n      if (!this.firstDragMove_) {\n        this.dragging_ = pointer;\n        this.dispatchOnObject(dragTarget, 'dragstart', originalEvt, pointer);\n        this.createOngoingDrag_(pointer, originalEvt);\n        delete this.lastPointerDown_[pointerId];\n        this.firstDragMove_ = true;\n      } else {\n        this.firstDragMove_ = false;\n      }\n\n    } else {\n      //will dispatch drag and schedule next drag\n      this.createOngoingDrag_(pointer, originalEvt);\n    }\n  }\n\n\n};\n\n\n/**\n * This method triggers the poitnerdown event on pointer target. It also sets dragging target\n * on the pointer if target is draggable.\n * @param {H.mapevents.Pointer} pointer pointer to which action is bound\n * @param {H.Map|H.map.Object} pointerTarget the target which is uder the pointer\n * @param {Event} originalEvt original event which is passed to custom event\n *\n */\nH.mapevents.handlers.Handler.prototype.dispatchpointerdown = function(pointer, pointerTarget, originalEvt) {\n  'use strict';\n  var that = this,\n      pointerType = pointer['type'],\n      //for mouse and pen drag can be triggered only for LMB or pen's button 0\n      canDrag = ((pointerType === 'mouse' || pointerType === 'pen') && originalEvt.button !== 0) ? false : true,\n      evt;\n\n  if (pointerTarget) {\n    pointer.setTarget(pointerTarget);\n    /**\n     * Store current pointer timestamp. It will be processed in\n     * pointerup to cehck if tap occured\n     */\n    that.lastPointerDown_[pointer['id']] = {\n      at: new H.math.Point(pointer['viewportX'], pointer['viewportY']),\n      target: pointer['target'],\n      ts: originalEvt['timeStamp']\n    };\n    if (pointer['type'] !== 'mouse') {\n      that.dispatchOnObject(pointerTarget, 'pointerenter', originalEvt, pointer, true);\n    }\n    evt = that.dispatchOnObject(pointerTarget, 'pointerdown', originalEvt, pointer);\n    //initialize drag target if draggable (consecutive pointer move will fire dragstart)\n    if (!that.dragging_ && canDrag) {\n      if (pointerTarget.draggable && !this.pointers.isDragTarget(pointerTarget)) {\n        pointer.setDragTarget(pointerTarget);\n      } else if (this.map.draggable && !evt['defaultPrevented'] && !this.pointers.isDragTarget(this.map)) {\n        pointer.setDragTarget(this.map);\n      }\n    }\n\n    this.setupLongpress_(pointer, originalEvt);\n  }\n};\n\n\n/**\n * Triggers pointer cancel event on the target map object. It also ends any ongoing drags.\n * @param {H.mapevents.Pointer} pointer pointer to which action is bound\n * @param {H.Map|H.map.Object} pointerTarget the target which is uder the pointer\n * @param {Event} originalEvt original event which is passed to custom event\n */\nH.mapevents.handlers.Handler.prototype.dispatchpointercancel = function(pointer, pointerTarget, originalEvt) {\n  'use strict';\n  pointer.setTarget(null);\n  if (pointerTarget) {\n    this.dispatchOnObject(pointerTarget, 'pointerleave', originalEvt, pointer, true);\n    this.dispatchOnObject(pointerTarget, 'pointercancel', originalEvt, pointer);\n  } else {\n    this.dispatchOnObject(this.map, 'pointercancel', originalEvt, pointer);\n  }\n\n  this.resolveDragEnd_(pointer, originalEvt);\n  //reset last pointer donw timestamp (use to measure tap trigger)\n  this.lastPointerDown_ = {};\n  this.cancelScheduled_(pointer['id'], this.longPress_);\n};\n\n\n/**\n * This method dispatches event on provided object. It creates custom event and\n * passes previously set pointers and changedpointers into the event object.\n *\n * @param {H.Map|H.map.Object} obj object on which event is being dispatched\n * @param {string} eventName name of the event dispatched on object\n * @param {Event} originalEvt original native event\n * @param {H.mapevents.Pointer} pointer pointer which triggered event\n * @param {boolean=} opt_preventPropagation explicitly prevent event from being propagated\n * @return {H.mapevents.Event|undefined}\n */\nH.mapevents.handlers.Handler.prototype.dispatchOnObject = function(obj, eventName,\n    originalEvt, pointer, opt_preventPropagation) {\n  'use strict';\n  var evt;\n  if (obj && typeof(obj['dispatchEvent']) === 'function') {\n    evt = new H.mapevents.Event(eventName,\n        this.pointers.asArray(), this.changedPointers.asArray(), this.pointers.getOnTarget(obj), pointer,\n        obj, originalEvt);\n    obj['dispatchEvent'](evt);\n  }\n  return evt;\n};\n\n\n/**\n * This method returns the curently assigned viewport's element\n * @return {HTMLElement}\n */\nH.mapevents.handlers.Handler.prototype.getViewPortElement = function() {\n  'use strict';\n  return this.viewPort_['element'];\n};\n\n\n/**\n * Function disposes all references.\n * @protected\n */\nH.mapevents.handlers.Handler.prototype.disposeInternal = function() {\n  'use strict';\n  var that = this;\n  that.addRemoveListeners_(true);\n  that.pointers.clear();\n  that.changedPointers.clear();\n  that.clearAllScheduled_(this.nextDrag_);\n  that.clearAllScheduled_(this.longPress_);\n  that.element_ = null;\n  that.eventsMap_ = null;\n  that.pointers = null;\n  that.changedPointers = null;\n  that.map = null;\n  that.lastDispatchedName_ = null;\n  that.lastTapped_ = null;\n  that.lastPointerDown_ = null;\n  that.dragging_ = null;\n  goog.Disposable.prototype.disposeInternal.call(this);\n};\n\n\n/**\n * Element used for events mapping wih listeners\n * @typedef {{\n *   eventName: (string),\n *   listener: (function()),\n *   target: (HTMLElement|undefined)\n * }}\n * @property {string} eventName name of the event\n * @property {function()} listener listener which handles the native event\n * @property {HTMLElement=} target optional element to which listener should be added (map viewport\n * element is default)\n */\nH.mapevents.handlers.Handler.Map;\n\n\n/**\n * Options used to configure the Handler\n * @typedef {{\n *   tapThreshold: (number|undefined),\n *   tapDistanceThreshold: (number|undefined),\n *   dblTapThreshold: (number|undefined),\n *   dblTapDistanceThreshold: (number|undefined),\n *   longPressThreshold: (number|undefined),\n *   longPressDistanceThreshold: (number|undefined)\n * }}\n * @property {number=} dblTapThreshold threshold between two taps to trigger double tap default is 500ms\n * @property {number=} dblTapDistanceThreshold distance threshold between two taps to trigger double tap default is 20px\n * @property {number=} longPressThreshold time after which longpress event will be\n * fired (if not interrupted by pointerup)\n * @property {number=} longPressDistanceThreshold time after which longpress event will be\n * fired (if not interrupted by pointerup)\n */\nH.mapevents.handlers.Handler.Options;\n\n\n",
		"goog.provide('H.mapevents.handlers.Touch');\n\ngoog.require('H.mapevents.Pointer');\ngoog.require('H.mapevents.PointerList');\ngoog.require('H.mapevents.handlers.Handler');\ngoog.require('H.mapevents.util');\n\n\n\n/**\n * Handles touch events on touch devices and converts touch events\n * to map custom pointer events\n * @constructor\n * @param {H.Map} map\n * @extends {H.mapevents.handlers.Handler}\n */\nH.mapevents.handlers.Touch = function(map) {\n  'use strict';\n\n  this.handleTouch = H.lang.bind(this.handleTouch, this);\n  H.mapevents.handlers.Handler.call(this, map, [\n    { eventName: 'touchstart', listener: this.handleTouch},\n    { eventName: 'touchmove', listener: this.handleTouch},\n    { eventName: 'touchend', listener: this.handleTouch},\n    { eventName: 'touchcancel', listener: this.handleTouch}\n  ]);\n\n  /**\n   * @private\n   */\n  this.touchToPointers_ = {\n    'touchstart': 'pointerdown',\n    'touchmove': 'pointermove',\n    'touchend': 'pointerup',\n    'touchcancel': 'pointercancel'\n  };\n\n  this.lastPointerPosition_ = {};\n\n  //store imprint links to void preventing default on touch\n  var imprint = map.getImprint(),\n      imprintElement = imprint ? imprint.getElement() : null;\n  /**\n   * @private\n   */\n  this.imprintLinks_ = imprintElement ? Array.prototype.slice.call(imprintElement.querySelectorAll('a'), 0) :\n      [];\n};\nH.lang.inherits(H.mapevents.handlers.Touch, H.mapevents.handlers.Handler);\n\n\n/**\n * Function delegates pointer creation to handlers depending on event types.\n * Calculates the map offset\n * @param {Event} evt\n */\nH.mapevents.handlers.Touch.prototype.managePointers = function(evt) {\n  'use strict';\n  var offset = H.mapevents.util.findOffset(this.getViewPortElement()),\n      evtType = evt['type'],\n      changedTouches = evt['changedTouches'],\n      l = changedTouches.length,\n      viewportX,\n      viewportY,\n      absX,\n      absY,\n      pointer,\n      touch,\n      i;\n\n  this.changedPointers.clear();\n\n  for (i = 0; i < l; i++) {\n    touch = changedTouches[i];\n    pointer = this.pointers.byId(touch['identifier']);\n    viewportX = touch['pageX'] - offset['x'];\n    viewportY = touch['pageY'] - offset['y'];\n\n    if (!pointer) {\n      //touchstart no pointers on thescreen\n      pointer = new H.mapevents.Pointer(\n          viewportX,\n          viewportY,\n          touch['identifier'],\n          'touch'\n          );\n      this.pointers.push(pointer);\n      this.changedPointers.push(pointer);\n    } else if (evtType === 'touchmove') {\n      absX = Math.abs(pointer['viewportX'] - viewportX);\n      absY = Math.abs(pointer['viewportY'] - viewportY);\n      if (absX > 1 || absY > 1 || (absX === 1 && absY === 1)) {\n        /*\n         * Update pointer position and add to 'changedpointers' only if\n         * the position has really changed. This will drop dummy touchmove\n         * events in some mobile devices which are triggered even if there is no\n         * position change at all\n         */\n        pointer.updatePosition(viewportX, viewportY);\n        this.changedPointers.push(pointer);\n      }\n    } else if (evtType === 'touchend') {\n      this.pointers.remove(pointer['id']);\n      this.changedPointers.push(pointer);\n    }\n  }\n\n};\n\n\n/**\n * This method checks for lost pointers and it is used on touch start\n * (i.e element was removed during touchmove and no touchend or touchcancel was fired from the browser).\n * On touchstart touches.length should always be greater that internal pointers list length since we add new touch\n * to the list otherwise it means that there are some leftovers. It is not ideal\n * solution but works for now.\n * @param {Event} evt\n */\nH.mapevents.handlers.Touch.prototype.handleLostPointers = function(evt) {\n  'use strict';\n  var touches = evt['touches'],\n      pointersLen = this.pointers.length(),\n      clonedPointerList,\n      i;\n\n  if (evt['type'] === 'touchstart' && pointersLen >= touches.length) {\n\n    clonedPointerList = this.pointers.clone();\n    i = touches.length;\n    //filter out existing pointers\n    while (i--) {\n      clonedPointerList.remove(touches[i]['identifier']);\n    }\n\n    //remove remaining pointers from the main pointers list\n    i = clonedPointerList.length();\n    while (i--) {\n      this.pointers.remove(clonedPointerList.item(i)['id']);\n    }\n\n    //cancel the pointers\n    this.changedPointers = clonedPointerList;\n    //dispatch cancel events on removed pointers this should also cancel drag\n    this.processPointerEvent('pointercancel', evt);\n    this.changedPointers.clear();\n  }\n};\n\n\n/**\n * Listens to touch events and dispatches mapped pointer events\n * @param {Event} evt\n */\nH.mapevents.handlers.Touch.prototype.handleTouch = function(evt) {\n  'use strict';\n  this.handleLostPointers(evt);\n  if (this.touchToPointers_[evt['type']]) {\n    this.managePointers(evt);\n    this.processPointerEvent(this.touchToPointers_[evt['type']], evt);\n    if (this.imprintLinks_.indexOf(evt.target) === -1) {\n      evt['preventDefault']();\n    }\n  }\n};\n\n\n/**\n * function disposes the object\n * @protected\n */\nH.mapevents.handlers.Touch.prototype.disposeInternal = function() {\n  'use strict';\n  this.imprintLinks_ = null;\n  H.mapevents.handlers.Handler.prototype.disposeInternal.call(this);\n};\n\n",
		"goog.provide('H.mapevents.handlers.MSPointer');\n\ngoog.require('H.mapevents.Pointer');\ngoog.require('H.mapevents.PointerList');\ngoog.require('H.mapevents.handlers.Handler');\ngoog.require('H.mapevents.util');\n\n\n\n/**\n * MSPointer class unifies the pointer events for IE10 and IE11. It transforms\n * native pointer events to internal pointer events.\n *\n * @constructor\n * @extends {H.mapevents.handlers.Handler}\n * @param {H.Map} map\n */\nH.mapevents.handlers.MSPointer = function(map) {\n  'use strict';\n  var handlers = [];\n  handlers = this.createHandlerMap_();\n  if (navigator['pointerEnabled'] || navigator['msPointerEnabled']) {\n    handlers.push({ eventName: 'MSHoldVisual', listener: 'prevent' });\n  }\n  H.mapevents.handlers.Handler.call(this, map, handlers);\n\n};\nH.lang.inherits(H.mapevents.handlers.MSPointer, H.mapevents.handlers.Handler);\n\n\n/**\n * Fucntion creates the handler ma, which is used to attach pointer events\n * @private\n * @return {Array.<Object>}\n */\nH.mapevents.handlers.MSPointer.prototype.createHandlerMap_ = function() {\n  'use strict';\n  var that = this,\n      isIE11 = navigator['pointerEnabled'],\n      eventName,\n      platformEventName,\n      handlerMap = [];\n\n  this.handlePointerEvent = H.lang.bind(this.handlePointerEvent, this);\n\n  [\n    'MSPointerDown',\n    'MSPointerMove',\n    'MSPointerUp',\n    'MSPointerCancel',\n    'MSPointerOut',\n    'MSPointerOver'\n  ].forEach(function(msEventName) {\n    eventName = msEventName.toLowerCase().replace(/ms/g, ''); //create IE11 event names\n    platformEventName = isIE11 ? eventName : msEventName;\n    handlerMap.push({\n      eventName: platformEventName,\n      listener: that.handlePointerEvent,\n      target: (msEventName === 'MSPointerUp' || msEventName === 'MSPointerMove') ? window : null\n    });\n  });\n\n  return handlerMap;\n};\n\n\n/**\n * @enum {string}\n */\nH.mapevents.handlers.MSPointer.Type = {\n  MOUSE: 'mouse',\n  PEN: 'pen',\n  TOUCH: 'touch'\n};\n\n\n/**\n * @enum {string}\n */\nH.mapevents.handlers.MSPointer.NumToType = {\n  '2': H.mapevents.handlers.MSPointer.Type.TOUCH,\n  '3': H.mapevents.handlers.MSPointer.Type.PEN,\n  '4': H.mapevents.handlers.MSPointer.Type.MOUSE\n};\n\n\n/**\n * This method creates map pointer depending on input parameters\n * @param {Event} evt\n * @param {H.math.IPoint} atCoords\n * @return {H.mapevents.Pointer}\n */\nH.mapevents.handlers.MSPointer.prototype.createPointer = function(evt, atCoords) {\n  'use strict';\n  var pointer,\n      pointerType = evt['pointerType'];\n\n  if (typeof(pointerType) === 'number') {\n    pointerType = H.mapevents.handlers.MSPointer.NumToType[pointerType];\n  }\n\n  pointer = new H.mapevents.Pointer(\n      atCoords['x'],\n      atCoords['y'],\n      evt['pointerId'],\n      pointerType\n      );\n  this.pointers.push(pointer);\n  return pointer;\n};\n\n\n/**\n * @param {Event} evt\n * @protected\n * @return {boolean}\n */\nH.mapevents.handlers.MSPointer.prototype.prevent = function(evt) {\n  'use strict';\n  evt.preventDefault();\n  return false;\n};\n\n\n/**\n * Common entry point for all poitner events. Will clear up changedPointers list\n * it will create pointers if ncessary calculate viewport coordinates and\n * use proper handler for particular event\n * @param {Event} evt\n */\nH.mapevents.handlers.MSPointer.prototype.handlePointerEvent = function(evt) {\n  'use strict';\n\n  //update events names if ie10 i.e MsPointerUp -> pointerup\n  var evtType = navigator.pointerEnabled ? evt.type : evt.type.toLowerCase().replace(/ms/g, ''),\n      offset = H.mapevents.util.findOffset(this.element),\n      pointer = this.pointers.byId(evt['pointerId']),\n      viewportX = evt['pageX'] - offset['x'],\n      viewportY = evt['pageY'] - offset['y'],\n      pointerType = H.mapevents.handlers.MSPointer.NumToType[evt['pointerType']] || evt['pointerType'];\n\n  if (!pointer && !(evtType in {\n    /**\n     * (using handler names since evt.type differs between IEs)\n     * There is no pointer on the list wich means 'up' was fired and\n     * if current handler is 'diregistering handler' up, out, cancel,\n     * we should not create a map pointer and fire any events.\n     */\n    'pointerup': 1,\n    'pointerout': 1,\n    'pointercancel': 1\n  }) && (pointerType !== H.mapevents.handlers.MSPointer.Type.TOUCH || evtType === 'pointerdown')) {\n    //for touch create pointers only during poitnerdown\n    //no pointer create one\n    pointer = this.createPointer(evt, /** @type {H.math.IPoint} */ ({\n      'x': viewportX,\n      'y': viewportY\n    }));\n  }\n\n  if (pointer) {\n\n    if (evtType in {\n      'pointerup': 1,\n      'pointercancel' : 1\n    }) {\n      //remove pointer from device pointers if pointerup or pointercancel is fired\n      this.pointers.remove(pointer['id']);\n    }\n\n    /**\n     * Remove mouse and pen pointers when user used his finger\n     */\n    if (evtType === 'pointerdown' && evt['pointerType'] === 'touch') {\n      this.pointers.removeByType('mouse');\n      this.pointers.removeByType('pen');\n    }\n\n    //add pointer to currently changed pointers\n    this.changedPointers.push(pointer);\n\n    if (evtType !== 'pointermove') {\n      pointer.updatePosition(viewportX, viewportY);\n      /**\n       * For pointerout and pointerover dispatch 'pointermove'. Handler\n       * will change by comparing poitner targets to poitnerenter and pointerleave if necessary\n       */\n      this.processPointerEvent(evtType === 'pointerout' || evtType === 'pointerover' ?\n          'pointermove' : evtType, evt);\n\n    } else if ((pointer['viewportX'] !== viewportX || pointer['viewportY'] !== viewportY) &&\n        evt.target !== document.documentElement) {\n      /**\n       * Dispatch pointermove only if position is changed. Surface tends to\n       * fire pointermove events even if you just press and hold\n       */\n      pointer.updatePosition(viewportX, viewportY);\n      this.processPointerEvent(evtType, evt);\n    }\n  }\n\n  this.changedPointers.clear();\n};\n\n",
		"goog.provide('H.mapevents.WheelEvent');\n\n\n\n/**\n * WheelEvent is fired when the mouse wheel is used over the map. It contains information\n * about cursor position and the map object which resides directly\n * under the cursor.\n *\n * @constructor\n * @param {number} deltaY The wheel move delta on y-axis\n * @param {number} viewportX The x coordinate on the viewport\n * @param {number} viewportY The y coordinate on the viewport\n * @param {H.Map|H.map.Object} target The event's target element\n * @param {Event} originalEvent target of the event\n * @extends {H.util.Event}\n * @publish\n * @export\n */\nH.mapevents.WheelEvent = function(deltaY, viewportX, viewportY, target, originalEvent) {\n  'use strict';\n  H.util.getSuperProto(H.mapevents.WheelEvent).constructor.call(this, 'wheel');\n\n  /**\n   * Wheel move delta\n   * @publish\n   * @name H.mapevents.WheelEvent#delta\n   * @type {number}\n   */\n  this['delta'] = deltaY;\n\n  /**\n   * Map viewport x position\n   * @publish\n   * @name H.mapevents.WheelEvent#viewportX\n   * @type {number}\n   */\n  this['viewportX'] = viewportX;\n\n  /**\n   * Map viewport y position\n   * @publish\n   * @name H.mapevents.WheelEvent#viewportY\n   * @type {number}\n   */\n  this['viewportY'] = viewportY;\n\n  /**\n   * Target for the event\n   * @publish\n   * @name H.mapevents.WheelEvent#target\n   * @type {H.map.Object|H.Map}\n   */\n  this['target'] = target;\n\n  /**\n   * Original mouse wheel event\n   * @publish\n   * @name H.mapevents.WheelEvent#originalEvent\n   * @type {Event}\n   */\n  this['originalEvent'] = originalEvent;\n\n};\nH.lang.inherits(H.mapevents.WheelEvent, H.util.Event);\n",
		"goog.provide('H.mapevents.handlers.Wheel');\n\ngoog.require('H.mapevents.WheelEvent');\ngoog.require('H.mapevents.handlers.Handler');\ngoog.require('H.mapevents.util');\n\n\n\n/**\n * Wheel class unifies the mouse wheel events, and dispatches them\n * on map object or map events.\n * @constructor\n * @extends {H.mapevents.handlers.Handler}\n * @param {H.Map} map\n */\nH.mapevents.handlers.Wheel = function(map) {\n  'use strict';\n  var IS_W3C_CONFORM = 'onwheel' in document;\n\n  /**\n   * Detection whether the browsers supports the W3C Working Draft 11/2013 \"wheel\" or the older \"mousewheel\"\n   * Chrome and Firefox supports it, Safari 7.0 and Internet Explorer 9-11 not\n   * @private\n   * @type {boolean}\n   */\n  this.IS_W3C_CONFORM_ = IS_W3C_CONFORM;\n\n  /**\n   * Keeps the prefix to use when reading the event's delta values\n   * @private\n   * @type {string}\n   */\n  this.DELTA_PREFIX_ = (IS_W3C_CONFORM ? 'd' : 'wheelD') + 'elta';\n\n  this.handleWheel = H.lang.bind(this.handleWheel, this);\n\n  H.util.getSuperProto(H.mapevents.handlers.Wheel).constructor.call(this, map,\n      [{eventName: (IS_W3C_CONFORM ? '' : 'mouse') + 'wheel', listener: this.handleWheel }]);\n\n};\nH.lang.inherits(H.mapevents.handlers.Wheel, H.mapevents.handlers.Handler);\n\n\n/**\n * This method normalizes mouse wheel events\n * @param {Event} evt The original event\n * @param {number} viewportX The viewport's x coordinate\n * @param {number} viewportY  The viewport's x coordinate\n * @return {H.mapevents.WheelEvent}\n */\nH.mapevents.handlers.Wheel.prototype.normalize = function(evt, viewportX, viewportY) {\n  'use strict';\n  var DELTA_PREFIX = this.DELTA_PREFIX_,\n      deltaY = evt[DELTA_PREFIX + ((DELTA_PREFIX + 'Y') in evt ? 'Y' : '')],\n      absDeltaY,\n      deltaO,\n      abs;\n\n  if (deltaY) {\n    abs = Math.abs;\n    absDeltaY = abs(deltaY);\n\n    // If deltaY is at least 2 times greater than deltaX and deltaZ than we use the normalized deltaY,\n    // otherweise we set it to 0:\n    deltaY =\n        (!(deltaO = evt[DELTA_PREFIX + 'X']) || absDeltaY / abs(deltaO) >= 3) &&\n        (!(deltaO = evt[DELTA_PREFIX + 'Z']) || absDeltaY / abs(deltaO) >= 3) ?\n        ((deltaY > 0) - (deltaY < 0)) * (this.IS_W3C_CONFORM_ ? 1 : -1) :\n        0;\n  }\n\n  // The target will be set later on:\n  return new H.mapevents.WheelEvent(deltaY, viewportX, viewportY, null, evt);\n};\n\n\n/**\n * This method handles the browser wheel event and dispatches map\n * event on the target\n * @param {Event} evt\n *\n */\nH.mapevents.handlers.Wheel.prototype.handleWheel = function(evt) {\n  'use strict';\n  var offset = H.mapevents.util.findOffset(this.element),\n      normalizedEvent;\n\n  normalizedEvent = this.normalize(evt, evt['pageX'] - offset['x'], evt['pageY'] - offset['y']);\n\n  // We ignore the wheel event if the normalization results in a delta of 0:\n  if (normalizedEvent['delta']) {\n    normalizedEvent['target'] = this.map.getObjectsAt(normalizedEvent['viewportX'], normalizedEvent['viewportY'])[0];\n\n    if (normalizedEvent['target'] && typeof(normalizedEvent['target']['dispatchEvent']) === 'function') {\n      normalizedEvent['target']['dispatchEvent'](normalizedEvent);\n    }\n\n    if (!normalizedEvent['defaultPrevented']) {\n      this.map['dispatchEvent'](normalizedEvent);\n    }\n  }\n\n};\n\n\n\n",
		"goog.provide('H.mapevents.handlers.Mouse');\n\ngoog.require('H.mapevents.Pointer');\ngoog.require('H.mapevents.PointerList');\ngoog.require('H.mapevents.handlers.Handler');\ngoog.require('H.mapevents.util');\n\n\n\n/**\n * Mouse handler transforms mouse events to internal\n * pointer events for target map instance.\n *\n * @constructor\n * @extends {H.mapevents.handlers.Handler}\n * @param {H.Map} map\n *\n */\nH.mapevents.handlers.Mouse = function(map) {\n  'use strict';\n  var handlerName = 'handleMouse',\n      win = window;\n\n  this.handleMouse = H.lang.bind(this.handleMouse, this);\n\n  H.mapevents.handlers.Handler.call(this, map, [\n    { eventName: 'mousedown', listener: this.handleMouse },\n    { eventName: 'mousemove', listener: this.handleMouse, target: win},\n    { eventName: 'mouseup', listener: this.handleMouse, target: win},\n    { eventName: 'mouseover', listener: this.handleMouse },\n    { eventName: 'mouseout', listener: this.handleMouse },\n    { eventName: 'dragstart', listener: this.ondragstart_ }\n  ]);\n\n};\nH.lang.inherits(H.mapevents.handlers.Mouse, H.mapevents.handlers.Handler);\n\n\n/**\n * This method creates the Pointer object used by the mouse handler.\n * @param {Event} evt\n * @param {H.math.IPoint} atCoords screen coordinates for the pointer\n * @return {H.mapevents.Pointer}\n */\nH.mapevents.handlers.Mouse.prototype.createPointer = function(evt, atCoords) {\n  'use strict';\n  var pointer = new H.mapevents.Pointer(\n      atCoords['x'],\n      atCoords['y'],\n      1,\n      'mouse'\n      );\n  this.pointers.push(pointer);\n  return pointer;\n};\n\n\n/**\n * Entry point for all mouse events. It handles native mouse events and\n * dispatches pointer events on the objects and the map itself.\n *\n * @param {Event} evt\n */\nH.mapevents.handlers.Mouse.prototype.handleMouse = function(evt) {\n  'use strict';\n\n  var evtType = evt['type'],\n      offset = H.mapevents.util.findOffset(this.element),\n      atCoords = /** @type {H.math.IPoint} */ ({\n        'x': evt['pageX'] - offset['x'],\n        'y': evt['pageY'] - offset['y']\n      }),\n      pointer = this.pointers.item(0) || this.createPointer(evt, atCoords);\n\n  //add pointer to changed pointers\n  this.changedPointers.push(pointer);\n  pointer.updatePosition(atCoords.x, atCoords.y);\n  if (evtType in {\n    'mousemove': 1,\n    'mouseover': 1,\n    'mouseout': 1\n  }) {\n    //for mousemove, mouseover, mouseout dispatch the pointermove event it converts over and out\n    // to pointerenter and pointerleave internall events\n    this.processPointerEvent('pointermove', evt);\n  } else {\n    //change mouse event to coresponding pointer event for others\n    this.processPointerEvent(evtType.replace('mouse', 'pointer'), evt);\n  }\n\n  //clear changed pointers after pointer events were dispatched\n  this.changedPointers.clear();\n};\n\n\n/**\n * Cancel dragstart event. Dragging the map objects is handles by the map event internally.\n * @param {Event} evt\n * @private\n */\nH.mapevents.handlers.Mouse.prototype.ondragstart_ = function(evt) {\n  'use strict';\n  evt.preventDefault();\n};\n\n\n\n\n",
		"goog.provide('H.mapevents.MapEvents');\n\ngoog.require('goog.Disposable');\ngoog.require('H.mapevents.handlers.MSPointer');\ngoog.require('H.mapevents.handlers.Mouse');\ngoog.require('H.mapevents.handlers.Touch');\ngoog.require('H.mapevents.handlers.Wheel');\n\n\n\n/**\n * MapEvents enable the events functionality on the map and one the map objects.\n * By using this extension it is possible to listen to events on map objects\n * like markers, polyline and the mapevents object itself. Events are triggered\n * depending on user interaction. Please check the Events Summary section\n * for the list of events fired my this class and by the map objects.\n *\n * @constructor\n * @param {H.Map} map map instance which is used for firing events\n * @extends {H.util.Disposable}\n * @publish\n * @export\n *\n * @example\n * //prerequisites: mapInstance and marker is initialized\n * mapInstance.addObject(marker);\n * var mapevts = new H.mapevents.MapEvents(mapInstance);\n * //add listener to map\n * map.addEventListener('pointermove', function(e) {...});\n * //add listener to the marker\n * marker.addEventListener('pointerenter', function(e) {...});\n * marker.addEventListener('pointerleave', function(e) {...});\n */\nH.mapevents.MapEvents = function(map) {\n  'use strict';\n  if (H.mapevents.MapEvents.usedBy_.indexOf(map) !== -1) {\n    throw new Error('InvalidArgument: map is already in use');\n  }\n\n  this.map_ = map;\n  H.mapevents.MapEvents.usedBy_.push(map);\n\n  /**\n   * @private\n   */\n  this.touchHandler_ = null;\n\n  /**\n   * @private\n   */\n  this.mouseHandler_ = null;\n\n  /**\n   * @private\n   */\n  this.wheelHandler_ = null;\n\n\n  this.setupHandlers_();\n  this.map_.addOnDisposeCallback(this.dispose, this);\n\n  H.util.Disposable.call(this);\n};\nH.lang.inherits(H.mapevents.MapEvents, H.util.Disposable);\n\n\n/**\n * Array stores references to H.Map instances to prevent double instantiation\n * of MapEvents with the same map.\n * @type {Array.<H.Map>}\n * @private\n */\nH.mapevents.MapEvents.usedBy_ = [];\n\n\n/**\n * This method sets up the plaform handlers which will\n * itnernally conver native events to custom map events\n * @private\n */\nH.mapevents.MapEvents.prototype.setupHandlers_ = function() {\n  'use strict';\n  if (navigator['msPointerEnabled'] || navigator['pointerEnabled']) {\n    this.touchHandler_ = new H.mapevents.handlers.MSPointer(this.map_);\n  } else {\n    this.touchHandler_ = new H.mapevents.handlers.Touch(this.map_);\n    this.mouseHandler_ = new H.mapevents.handlers.Mouse(this.map_);\n  }\n  this.wheelHandler_ = new H.mapevents.handlers.Wheel(this.map_);\n};\n\n\n/**\n * List of event fired by {@link H.Map} and all map objects added to map i.e {@link H.map.Marker}\n * To enable the listed events on map and map objects you need to initialize the MapEvents instance\n * and pass the Map instance as an argument to the constructor.\n * @example\n * var mapEvents = new H.mapevents.MapEvents(mapInstance);\n * mapInstance.addEventListener('drag', function(mapEvent) {\n *   //execute code when map is being dragged\n * })\n *\n * @enum {string}\n */\nH.mapevents.MapEvents.EventType = {\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) has reached the map surface.\n   * It equalivement to platform: mousedown, touchstart, pointerdown.\n   *\n   * @event H.mapevents.MapEvents#pointerdown\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERDOWN: 'pointerdown',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) has left the map surface.\n   * It equalivement to platform's: mouseup, touchend, pointerup.\n   *\n   * @event H.mapevents.MapEvents#pointerup\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERUP: 'pointerup',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) is moved over the surface.\n   * It equalivement to platform's: mousemove, touchmove, pointermove.\n   * @event H.mapevents.MapEvents#pointermove\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERMOVE: 'pointermove',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) has entered the object area.\n   * It equalivement to platform's: mouseenter, touchenter, pointerenter.\n   * Note: this events is not propagated to the mapEvents object if triggered by the\n   * map object (i.e marker).\n   *\n   * @event H.mapevents.MapEvents#pointerenter\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERENTER: 'pointerenter',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) has left the target object area.\n   * It equalivement to platform's: mouseleave, touchleave, pointerleave.\n   * Note: this events is not propagated to the mapEvents object if triggered by the\n   * map object (i.e marker).\n   *\n   * @event H.mapevents.MapEvents#pointerleave\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERLEAVE: 'pointerleave',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) has been cancelled by the browser.\n   * It equalivement to platform's: touchcancel, pointercancel.\n   *\n   * @event H.mapevents.MapEvents#pointercancel\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  POINTERCANCEL: 'pointercancel',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) started dragging the target.\n   * This event is only fired if the target object has {@code draggable} property set\n   * to true.\n   *\n   * @event H.mapevents.MapEvents#dragstart\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  DRAGSTART: 'dragstart',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) is dragging the target.\n   * This event is only fired if the target object has {@code draggable} property set\n   * to true.\n   *\n   * @event H.mapevents.MapEvents#drag\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  DRAG: 'drag',\n\n  /**\n   * Signifies this the pointer (mouse, pen, touch) stopped dragging the target.\n   * This event is only fired if the target object has {@code draggable} property set\n   * to true.\n   *\n   * @event H.mapevents.MapEvents#dragend\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  DRAGEND: 'dragend',\n\n  /**\n   * Signifies this the pointer (touch, pen, mouse) has touched the map (or object)\n   * surface for a moment.\n   *\n   * @event H.mapevents.MapEvents#tap\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  TAP: 'tap',\n\n  /**\n   * Signifies this the pointer (touch, pen) has touched the map (or object)\n   * surface twice in a row for a moment.\n   *\n   * @event H.mapevents.MapEvents#dbltap\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  DBLTAP: 'dbltap',\n\n  /**\n   * This event is dispatched on pointer target after pointer down has occured\n   * and no pointer up was triggered and pointer stayed in place for a longer time.\n   *\n   * @event H.mapevents.MapEvents#longpress\n   * @type {H.mapevents.Event}\n   * @publish\n   */\n  LONGPRESS: 'longpress'\n};\n\n\n/**\n * This method destroys the MapEvents by removing all handlers from the map object.\n * After calling this function mapEvents and map objects will not trigger any events.\n * This object will be disposed automatically if the corresponding map object\n * is disposed.\n * @export\n * @publish\n */\nH.mapevents.MapEvents.prototype.dispose = function() {\n  'use strict';\n  this.map_ = null;\n  this.touchHandler_.dispose();\n  this.wheelHandler_.dispose();\n  if (this.mouseHandler_) {\n    this.mouseHandler_.dispose();\n  }\n  H.mapevents.MapEvents.usedBy_.splice(\n      H.mapevents.MapEvents.usedBy_.indexOf(this.map_), 1);\n  H.util.dispose(this);\n};\n\n\n/**\n * This method returns map into which events are attached\n * @export\n * @publish\n * @return {H.Map}\n */\nH.mapevents.MapEvents.prototype.getAttachedMap = function() {\n  'use strict';\n  return this.map_;\n};\n\n",
		"goog.provide('H.mapevents.Behavior');\n\ngoog.require('H.mapevents.Event');\n\n\n\n/**\n * Behavior class uses map events and adds behavior funcitonality to the map.\n * This allows map panning and zooming via using mouse wheel\n *\n * @constructor\n *\n * @param {H.mapevents.MapEvents} mapEvents previously initialized map events instance\n * @param {H.mapevents.Behavior.Options} options additional options (i.e kinetics)\n * @extends {H.util.Disposable}\n * @example\n * //add map events functionality to the map\n * var mapEvents = new H.mapevents.MapEvents(mapInstance);\n * //add behavior to the map\n * var behavior = new H.mapevents.Behavior(mapEvents);\n * //from here map is pannable\n *\n * @publish\n * @export\n */\nH.mapevents.Behavior = function(mapEvents, options) {\n  'use strict';\n\n  if (H.mapevents.Behavior.usedBy_.indexOf(mapEvents) !== -1) {\n    throw new Error('InvalidArgument: events are already used');\n  }\n\n  var opts = options || {},\n          map,\n          engineType,\n          viewPortEl;\n\n  H.util.Disposable.call(this);\n\n  /**\n   * @private\n   */\n  this.map_ = map = mapEvents.getAttachedMap();\n\n  /**\n   * @private\n   * @type {H.mapevents.MapEvents}\n   */\n  this.mapEvents_ = mapEvents;\n  H.mapevents.Behavior.usedBy_.push(mapEvents);\n\n  //make map draggable\n  this.map_.draggable = true;\n\n  /**\n   * @private\n   */\n  this.zoomDuration_ = opts['zoomDuration'] || 300;\n\n  /**\n   * @private\n   */\n  this.kinetics_ = opts['kinetics'] || {\n    duration: 600,\n    ease: H.util.animation.ease.EASE_OUT_QUAD\n  };\n\n  /**\n   * @private\n   */\n  this.enableAll_ = H.mapevents.Behavior.DRAGGING +\n          H.mapevents.Behavior.WHEELZOOM +\n          H.mapevents.Behavior.DBLTAPZOOM;\n\n\n  this.enable(opts['enabled'] || this.enableAll_);\n\n  engineType = H.Map['EngineType'];\n\n  /**\n   * @private\n   */\n  this.viewPort_ = this.map_.getViewPort();\n\n  /**\n   * @private\n   */\n  this.viewPortElement_ = this.viewPort_['element'];\n\n  /**\n   * @private\n   */\n  this.viewModel_ = this.map_.getViewModel();\n\n  /**\n   * @private\n   */\n  this.zooming_ = false;\n\n  /**\n   * @private\n   */\n  this.p2dType_ = engineType['P2D'];\n\n  this.viewPortElement_.style.msTouchAction = 'none';\n  this.viewPortElement_.style.touchAction = 'none';\n\n  map['addEventListener']('dragstart', this.ondragstart_, false, this);\n  map['addEventListener']('drag', this.ondrag_, false, this);\n  map['addEventListener']('dragend', this.ondragend_, false, this);\n  map['addEventListener']('wheel', this.onwheel_, false, this);\n  map['addEventListener']('dbltap', this.ondoubletap_, false, this);\n  map['addEventListener']('tap', this.ontap_, false, this);\n  map['addEventListener']('pointermove', this.pointermove_, false, this);\n  H.util.events.listen(this.viewPortElement_, 'contextmenu', this.oncontextmenu_, false, this);\n\n  mapEvents.addOnDisposeCallback(this.dispose, this);\n};\nH.lang.inherits(H.mapevents.Behavior, H.util.Disposable);\n\n\n/**\n * Array stores references to H.mapevents.MapEvents instances to prevent double instantiation\n * of Behavior with the same MapEvents.\n * @private\n * @type {Array.<H.mapevents.MapEvents>}\n */\nH.mapevents.Behavior.usedBy_ = [];\n\n\n/**\n * @type {number}\n * @private\n */\nH.mapevents.Behavior.prototype.enabled_ = 0;\n\n\n/**\n * Map responds to user dragging via mouse or touch\n * @const\n * @type {number}\n * @publish\n * @export\n */\nH.mapevents.Behavior.DRAGGING = 1;\n\n\n/**\n * Map zooms in or out in respond to mouse wheel events\n * @publish\n * @const\n * @type {number}\n * @export\n */\nH.mapevents.Behavior.WHEELZOOM = 2;\n\n\n/**\n * Map zooms in or out in response to double click or double tap.\n * For double tap if more that one touches are on the screen map will zoom out.\n * @publish\n * @const\n * @type {number}\n * @export\n */\nH.mapevents.Behavior.DBLTAPZOOM = 4;\n\n\n/**\n * This methos is being called when map dragging is initialized. It\n * handles the drag and initializes map interaction.\n * @param {H.mapevents.Event} evt event fired by the map\n * @private\n */\nH.mapevents.Behavior.prototype.ondragstart_ = function(evt) {\n  'use strict';\n  var pointers = evt['pointers'],\n          viewPort = this.viewPort_,\n          pointer1 = pointers[0],\n          pointer2 = pointers[1] || {};\n\n  if (this.enabled_ & H.mapevents.Behavior.DRAGGING) {\n    viewPort['startInteraction'](16 + 1, this.kinetics_);\n    viewPort['interaction'](pointer1['viewportX'],\n        pointer1['viewportY'], pointer2['viewportX'], pointer2['viewportY']);\n  }\n};\n\n\n/**\n * This method is being called during the map dragging. It handles\n * interaction and repositions the map\n * @param {H.mapevents.Event} evt event fired by the map\n * @private\n */\nH.mapevents.Behavior.prototype.ondrag_ = function(evt) {\n  'use strict';\n  var pointer1 = evt['pointers'][0],\n          pointer2 = evt['pointers'][1] || {};\n  if (this.enabled_ & H.mapevents.Behavior.DRAGGING) {\n    this.viewPort_['interaction'](pointer1['viewportX'],\n        pointer1['viewportY'], pointer2['viewportX'], pointer2['viewportY']);\n    evt['originalEvent'].preventDefault();\n  }\n};\n\n\n/**\n * This method is being called when map dragging is finished. It\n * ends map interaction.\n * @param {H.mapevents.Event} evt event fired by the map\n * @private\n */\nH.mapevents.Behavior.prototype.ondragend_ = function(evt) {\n  'use strict';\n  var currentType = evt['currentPointer'].type,\n          pointers = evt['pointers'],\n          pointer1 = pointers[0],\n          pointer2 = pointers[1] || {},\n          viewPort = this.viewPort_;\n\n  if (this.enabled_ & H.mapevents.Behavior.DRAGGING) {\n    viewPort['endInteraction'](!this.kinetics_);\n  }\n};\n\n\n/**\n * This method does the actuall zooming on the map\n * @param {number} from start zoom\n * @param {number} to destination zoom\n * @param {number} atX zoom target x map viewport coordinate\n * @param {number} atY zoom target y map viewport coordinate\n */\nH.mapevents.Behavior.prototype.zoom = function(from, to, atX, atY) {\n  'use strict';\n  var that = this,\n      map = this.map_,\n      delta = +to - +from,\n      vm = map.getViewModel();\n\n  if (isNaN(+from)) {\n    throw new Error('start zoom needs to be a number');\n  }\n\n  if (isNaN(+to)) {\n    throw new Error('to zoom needs to be a number');\n  }\n\n  if (delta !== 0) {\n    vm['startControl'](null, atX, atY);\n    vm['control'](0, 0, (delta / delta) * 0.006);\n    vm['endControl'](true, function(endView) {\n      endView['zoom'] = to;\n    });\n  }\n};\n\n\n/**\n * This method handles the mouse wheel events triggered on\n * the map. It zooms in or out depending on the wheel delta\n * @param {H.mapevents.Event} evt event fired by the map\n * @private\n */\nH.mapevents.Behavior.prototype.onwheel_ = function(evt) {\n  'use strict';\n  var delta,\n      startZoom,\n      map,\n      targetZoom;\n\n  if (this.enabled_ & H.mapevents.Behavior.WHEELZOOM) {\n    delta = evt['delta'];\n    startZoom = this.map_.getZoom();\n    targetZoom = Math[delta < 0 ? 'ceil' : 'floor'](startZoom - delta);\n    map = this.map_;\n    if (map.getEngine()['type'] === this.p2dType_) {\n      this.zoom(startZoom, targetZoom, evt['viewportX'], evt['viewportY']);\n    } else {\n      var cam = this.map_.getViewModel().getCameraData();\n      cam['fov'] += delta * 16;\n      map.getViewModel().setCameraData(cam);\n    }\n    evt['originalEvent'].preventDefault();\n  }\n};\n\n\n/**\n * @param {H.mapevents.Event} evt\n * @private\n */\nH.mapevents.Behavior.prototype.ontap_ = function(evt) {\n  'use strict';\n  var pointer = evt['currentPointer'],\n          engine = this.map_.getEngine(),\n          cam;\n\n  if (this.p2dType_ !== engine['type']) {\n    cam = this.map_.screenToCameraData(pointer['viewportX'], pointer['viewportY']);\n    this.map_.getViewModel().setCameraData(cam);\n  }\n};\n\n\n/**\n * @param {H.mapevents.Event} evt\n * @private\n */\nH.mapevents.Behavior.prototype.pointermove_ = function(evt) {\n  'use strict';\n  var pointer = evt['currentPointer'],\n          engine = this.map_.getEngine();\n  engine.setPointer(pointer['viewportX'], pointer['viewportY']);\n};\n\n\n/**\n * This method handles double tap zoom. Whenever use taps the map quickly two times,\n * map will zoom in by one level. If there are two fingers on the map and\n * one of the double tap map will zoom out for one level.\n * @param {H.mapevents.Event} evt event fired by the map\n * @private\n */\nH.mapevents.Behavior.prototype.ondoubletap_ = function(evt) {\n  'use strict';\n  var pointer = evt['currentPointer'],\n          startZoom = this.map_.getZoom(),\n          type = evt['currentPointer'].type,\n          engine = this.map_.getEngine(),\n          targetZoom;\n  if (this.p2dType_ === engine['type']) {\n    if (type === 'mouse') {\n      targetZoom = startZoom + (evt['originalEvent']['button'] === 0 ? 1 : -1);\n    } else {\n      targetZoom = startZoom + (evt['pointers'].length > 0 ? -1 : 1);\n    }\n\n    if (this.enabled_ & H.mapevents.Behavior.DBLTAPZOOM) {\n      this.zoom(startZoom, targetZoom, pointer['viewportX'], pointer['viewportY']);\n    }\n  }\n};\n\n\n/**\n * This methis prevents browser menu from being displayed\n * @param {H.mapevents.Event} evt\n * @return {boolean}\n * @private\n */\nH.mapevents.Behavior.prototype.oncontextmenu_ = function(evt) {\n  'use strict';\n  if (this.enabled_ & H.mapevents.Behavior.DBLTAPZOOM) {\n    evt['preventDefault']();\n    return false;\n  }\n  return true;\n};\n\n\n/**\n * This method destroys all map interaction handling. Should be\n * used when the behavior functionality is disposed. Behavior object\n * will also be disposed (this function will be called)\n * when attached {@link H.mapevents.MapEvents} object is dispose.\n *\n * @publish\n * @export\n */\nH.mapevents.Behavior.prototype.dispose = function() {\n  'use strict';\n  var map = this.map_;\n  if (map) {\n    map.draggable = false;\n    map['removeEventListener']('dragstart', this.ondragstart_, false, this);\n    map['removeEventListener']('drag', this.ondrag_, false, this);\n    map['removeEventListener']('dragend', this.ondragend_, false, this);\n    map['removeEventListener']('wheel', this.onwheel_, false, this);\n    map['removeEventListener']('tap', this.ontap_, false, this);\n    map['removeEventListener']('dbltap', this.ondoubletap_, false, this);\n    map['removeEventListener']('pointermove', this.pointermove_, false, this);\n    this.map_ = null;\n  }\n  if (this.viewPortElement_) {\n    this.viewPortElement_.style.msTouchAction = '';\n    H.util.events.unlisten(this.viewPortElement_, 'contextmenu', this.oncontextmenu_, false, this);\n    this.viewPortElement_ = null;\n  }\n  if (this.viewModel_) {\n    this.viewModel_['removeEventListener']('sync', this.onzoomsync_, false, this);\n    this.viewModel_ = null;\n  }\n  this.viewPort_ = null;\n  this.kinetics_ = null;\n  H.mapevents.Behavior.usedBy_.splice(\n      H.mapevents.Behavior.usedBy_.indexOf(this.mapEvents_), 1);\n  H.util.dispose(this);\n};\n\n\n/**\n * This method disables the behavior functionality for\n * the map\n * @param {number=} opt_behavior value from {@link H.mapevents.Behavior.Behaviors} which\n * specifies particular behavior to be disabled. If no arguments passed it will disable all.\n * @publish\n * @export\n */\nH.mapevents.Behavior.prototype.disable = function(opt_behavior) {\n  'use strict';\n  this.viewPort_.endInteraction(true);\n  if (!opt_behavior) {\n    this.enabled_ = 0;\n    this.map_.draggable = false;\n  } else if (this.enabled_ & opt_behavior) {\n    this.enabled_ -= opt_behavior;\n    if (opt_behavior & H.mapevents.Behavior.DRAGGING) {\n      this.map_.draggable = false;\n    }\n  }\n\n};\n\n\n/**\n * This method re-enables the behavior functionality for the map.\n * @param {number=} opt_behavior value from {@link H.mapevents.Behavior.Behaviors} which\n * specifies particular behavior to be enabled. If no arguments passed it will enable all.\n * @publish\n * @export\n */\nH.mapevents.Behavior.prototype.enable = function(opt_behavior) {\n  'use strict';\n  if (!opt_behavior) {\n    this.enabled_ = this.enableAll_;\n    this.map_.draggable = true;\n  } else if (!(this.enabled_ & opt_behavior)) {\n    this.enabled_ += opt_behavior;\n    if (opt_behavior & H.mapevents.Behavior.DRAGGING) {\n      this.map_.draggable = true;\n    }\n  }\n};\n\n\n/**\n * This method checks if certain functionality is enabled\n * @param {number} behavior value from {@link H.mapevents.Behavior.Behaviors} against\n * which the check is being performed\n * @return {boolean}\n * @export\n * @publish\n */\nH.mapevents.Behavior.prototype.isEnabled = function(behavior) {\n  'use strict';\n  if (isNaN(behavior)) {\n    throw new Error('behavior: number required');\n  }\n  return !!(this.enabled_ & behavior);\n};\n\n\n/**\n * Options which are used to initialize the Behavior class.\n * @typedef {{\n *   kinetics: (H.util.kinetics.IKinetics|undefined),\n *   enable: (number)\n * }}\n *\n * @property {H.util.kinetics.IKinetics=} kinetics parameters for kinetic movement.\n * If set to false will prevent default settings from being used.\n *\n * @property {number} enable is a bitmask of {@link H.mapevents.Behavior.Behaviors}\n * which can enable only certain functionalities (all are enabled by default)\n * @publish\n */\nH.mapevents.Behavior.Options;\n",
		"/*\n * don't provide for uncompiled (will result in provide error due\n * to double provision if H-core is included\n */\nif (COMPILED) {\n  goog.provide('H');\n}\n\n\n/** @suppress {duplicate} */\nvar H = H || {};\n\n\n/**\n * This namespace contains classes and all functionality\n * related to map events and map behavior\n * @namespace H.mapevents\n * @publish\n */\ngoog.provide('H.mapevents');\n\n\ngoog.require('H.mapevents.Behavior');\ngoog.require('H.mapevents.MapEvents');\ngoog.require('H.mapevents.util');\n\n\n/**\n * Function returns the module build information\n * @return {H.util.BuildInfo}\n * @export\n */\nH.mapevents.buildInfo = function() {\n  'use strict';\n  return H.util.BuildInfo.get('{BUILD_NAME}', '{BUILD_VERSION}', '{BUILD_REVISION}');\n};\n"
	]
}