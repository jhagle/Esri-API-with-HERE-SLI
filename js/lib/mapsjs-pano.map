{
	"version": 3,
	"file": "mapsjs-panojs",
	"lineCount": 10,
	"mappings": "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",
	"sources": [
		"out/tmp/src/mapsjs/map/render/panorama/RenderEngine.js",
		"out/tmp/src/mapsjs/lang/namespace.js",
		"/home/here/repo/core/dev/node_modules/closure-library/closure/goog/base.js",
		"out/tmp/src/mapsjs/map/render/RenderEngine.js"
	],
	"names": [
		"H.map.render.panorama.RenderEngine",
		"viewPort",
		"viewModel",
		"dataModel",
		"opt_options",
		"viewPortContainer",
		"container",
		"ownerDocument",
		"createElement",
		"checkConfigured_",
		"H.map.render.panorama.RenderEngine.superClass_.constructor.call",
		"superClass_",
		"constructor",
		"call",
		"synchronize_",
		"H.lang.bind",
		"style",
		"width",
		"height",
		"position",
		"insertBefore",
		"firstChild",
		"pano_",
		"pano",
		"H",
		"PanoramaView",
		"ZOOM_VALUE",
		"zoomRange",
		"getZoomRange",
		"capabilities_",
		"getPitchRange",
		"getHeadingRange",
		"fovMin_",
		"fovMax_",
		"panoContainer_",
		"addEventListener",
		"H.map.render.panorama.RenderEngine.POV_CHANGED_",
		"rendered_",
		"moveTo",
		"cameraToPov_",
		"getCameraData",
		"goog.inherits",
		"H.map.render.RenderEngine",
		"goog.exportSymbol",
		"prototype",
		"type",
		"H.map.render.RenderEngine.EngineType",
		"goog.exportProperty",
		"H.map.render.panorama.RenderEngine.getClosestPanoramas",
		"coord",
		"callback",
		"PanoramaSearchService",
		"getClosestPanoramas",
		"H.map.render.panorama.RenderEngine.getImageUrl",
		"getImageUrl",
		"H.map.render.panorama.RenderEngine.configure",
		"appId",
		"appCode",
		"useHTTPS",
		"panoSettings",
		"PanoramaSettings",
		"set",
		"H.map.render.panorama.RenderEngine.configured",
		"startControl",
		"H.map.render.panorama.RenderEngine.prototype.startControl",
		"endInteraction",
		"beginControl",
		"H.map.render.panorama.RenderEngine.prototype.checkConfigured_",
		"H.lang.IllegalOperationError",
		"control",
		"H.map.render.panorama.RenderEngine.prototype.control",
		"moveX",
		"moveY",
		"moveZ",
		"angleX",
		"angleY",
		"angleZ",
		"zoom",
		"povFlags",
		"endControl",
		"H.map.render.panorama.RenderEngine.prototype.endControl",
		"startInteraction",
		"H.map.render.panorama.RenderEngine.prototype.startInteraction",
		"H.util.shims.now",
		"interaction",
		"H.map.render.panorama.RenderEngine.prototype.interaction",
		"x",
		"y",
		"opt_bx",
		"opt_by",
		"opt_timestamp",
		"isBifocal",
		"currentDistance",
		"interactionStarted_",
		"beginInteraction",
		"currentFov",
		"getZoom",
		"distance",
		"H.math.Point",
		"pointDistance_",
		"fovToSet",
		"distance_",
		"H.lang.UNDEF",
		"setZoom",
		"H.math.clamp",
		"wasChangingFov_",
		"interact",
		"H.map.render.panorama.RenderEngine.prototype.endInteraction",
		"H$map$render$panorama$RenderEngine.prototype",
		"H.map.render.panorama.RenderEngine.prototype",
		"zoomAt",
		"H.map.render.panorama.RenderEngine.prototype.zoomAt",
		"onResize",
		"H.map.render.panorama.RenderEngine.prototype.onResize",
		"resize",
		"disposeInternal",
		"H.map.render.panorama.RenderEngine.prototype.disposeInternal",
		"removeEventListener",
		"shutdown",
		"H.map.render.p2d.RenderEngine.superClass_.disposeInternal.call",
		"H.map.render.panorama.RenderEngine.prototype.synchronize_",
		"exitState_",
		"synchronize",
		"getPosition",
		"getPitch",
		"getHeading",
		"H.map.render.panorama.RenderEngine.prototype.rendered_",
		"ev",
		"dispatchEvent",
		"EventType",
		"RENDER",
		"screenToGeo",
		"H.map.render.panorama.RenderEngine.prototype.screenToGeo",
		"pixelToGeo",
		"geoToScreen",
		"H.map.render.panorama.RenderEngine.prototype.geoToScreen",
		"point",
		"geoToPixel",
		"screenToCameraData",
		"H.map.render.panorama.RenderEngine.prototype.screenToCameraData",
		"pixelToPov",
		"povToCamera_",
		"pov",
		"onViewUpdate",
		"H.map.render.panorama.RenderEngine.prototype.onViewUpdate",
		"camera",
		"fov",
		"lastFov_",
		"H.map.render.panorama.RenderEngine.prototype.cameraToPov_",
		"getBBox",
		"H.map.render.panorama.RenderEngine.prototype.getBBox",
		"H.geo.Rect.fromPoints",
		"getObjectsAt",
		"H.map.render.panorama.RenderEngine.prototype.getObjectsAt",
		"getCapabilities",
		"H.map.render.panorama.RenderEngine.prototype.getCapabilities",
		"setPointer",
		"H.map.render.panorama.RenderEngine.prototype.setPointer",
		"enter",
		"H.map.render.panorama.RenderEngine.prototype.enter",
		"H.util.doNothing",
		"getCamForBounds",
		"H.map.render.panorama.RenderEngine.prototype.getCamForBounds",
		"max",
		"exit",
		"H.map.render.panorama.RenderEngine.prototype.exit",
		"panoContainer",
		"that",
		"zIndex",
		"fadeout",
		"parentNode",
		"removeChild",
		"getPanoramaId",
		"H.map.render.panorama.RenderEngine.prototype.getPanoramaId"
	],
	"sourcesContent": [
		"goog.provide('H.map.render.panorama.RenderEngine');\n\n\ngoog.require('H.lang.IllegalOperationError');\ngoog.require('H.map.render.RenderEngine');\ngoog.require('H.math.Point');\n\n\n\n/**\n * Panorama rendering engine is responsible for presenting the geo\n * position provided by the view model as a 'street view'. In addition\n * it provides extra functionality specific to 'street view'.\n *\n * @constructor\n * @param {H.map.ViewPort} viewPort\n * @param {H.map.ViewModel} viewModel\n * @param {H.map.DataModel} dataModel\n * @param {H.map.render.p2d.RenderEngine.Options=} opt_options\n * @extends {H.map.render.RenderEngine}\n * @export\n * @publish\n */\nH.map.render.panorama.RenderEngine = function(viewPort, viewModel,\n    dataModel, opt_options) {\n  'use strict';\n  var canvas,\n      viewPortContainer = viewPort['element'],\n      container = viewPortContainer.ownerDocument.createElement('div'),\n      zoomRange,\n      pano;\n\n  this.checkConfigured_();\n\n  H.map.render.panorama.RenderEngine.superClass_.constructor.call(this,\n      viewPort, viewModel, dataModel, opt_options);\n\n  this.synchronize_ = H.lang.bind(this.synchronize_, this);\n\n  container.style.width = '100%';\n  container.style.height = '100%';\n  container.style.position = 'absolute';\n  viewPortContainer.insertBefore(container, viewPortContainer.firstChild);\n\n  this.pano_ = pano = new H.PanoramaView(container);\n\n  // TODO: sort out zoom-fov\n  this.ZOOM_VALUE = 20;\n\n  zoomRange = pano.getZoomRange();\n  this.capabilities_ = {\n    'zoom': {'min': this.ZOOM_VALUE, 'max': this.ZOOM_VALUE},\n    'camera': {\n      'pitch': pano.getPitchRange(),\n      'roll': {'min': 0, 'max': 0},\n      'yaw': pano.getHeadingRange(),\n      'fov': zoomRange\n    },\n    'capture': false\n  };\n\n  this.fovMin_ = zoomRange['min'];\n  this.fovMax_ = zoomRange['max'];\n\n  this.panoContainer_ = container;\n\n  pano.addEventListener(H.map.render.panorama.RenderEngine.POV_CHANGED_, this.synchronize_);\n  this.rendered_ = H.lang.bind(this.rendered_, this);\n  pano.addEventListener(H.map.render.panorama.RenderEngine.POV_CHANGED_, this.rendered_);\n  pano.moveTo(this.cameraToPov_(this.viewModel.getCameraData()));\n};\nH.lang.inherits(H.map.render.panorama.RenderEngine, H.map.render.RenderEngine);\n\n\n/**\n * @private\n * @type {string}\n */\nH.map.render.panorama.RenderEngine.POV_CHANGED_ = 'povchanged';\n\n\n/**\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.type =\n    H.map.render.RenderEngine.EngineType['PANORAMA'];\n\n\n/**\n * Searches for the closest panoramas for given geo coordinate. You can call this\n * method method multiple times without waiting for the callback, but intermediate\n * calls are implicitly cancelled and the callback gets 'undefined' as parameter.\n * @param {H.geo.IPoint} coord\n * @param {!function(Array.<H.map.render.panorama.RenderEngine.Panorama>)} callback\n * @export\n * @publish\n */\nH.map.render.panorama.RenderEngine.getClosestPanoramas = function(coord, callback) {\n  'use strict';\n  H.map.render.panorama.RenderEngine.prototype.checkConfigured_();\n  coord && H.PanoramaSearchService.getClosestPanoramas(\n      /** @type {H.PanoramaUtil.types.LatLng} */(coord), callback);\n};\n\n\n/**\n * Method returns URL of the panoorama preview based on the provided panorama object.\n * @publish\n * @export\n * @param {!H.map.render.panorama.RenderEngine.Panorama} pano\n * @return {string}\n */\nH.map.render.panorama.RenderEngine.getImageUrl = function(pano) {\n  H.map.render.panorama.RenderEngine.prototype.checkConfigured_();\n  return H.PanoramaSearchService.getImageUrl(/** @type {!H.PanoramaUtil.types.Panorama}*/ (pano));\n};\n\n\n/**\n * Method implemnts {@code H.platform.IConfigurable} interface. Must be called\n * before engine can be set on the map or any method invoked.\n * @param {string} appId\n * @param {string} appCode\n * @param {boolean} useHTTPS\n * @export\n * @publish\n */\nH.map.render.panorama.RenderEngine.configure = function(appId, appCode, useHTTPS) {\n  'use strict';\n  var panoSettings = H.PanoramaSettings;\n  panoSettings.set('auth_appId', appId);\n  panoSettings.set('auth_appCode', appCode);\n  panoSettings.set('server_useSSL', useHTTPS);\n  H.map.render.panorama.RenderEngine.configured = true;\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.startControl = function(\n    opt_kinetics, opt_atX, opt_atY) {\n  'use strict';\n  this.pano_.endInteraction(-1);\n  this.pano_.beginControl();\n};\n\n\n/**\n * @private\n */\nH.map.render.panorama.RenderEngine.prototype.checkConfigured_ = function() {\n  if (!H.map.render.panorama.RenderEngine.configured) {\n    throw new H.lang.IllegalOperationError(\n        H.map.render.panorama.RenderEngine,\n        'Engine must be configured with H.platform.Platform');\n  }\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.control = function(moveX,\n    moveY, moveZ, angleX, angleY, angleZ, zoom) {\n  'use strict';\n  var povFlags = H.PanoramaView['POV_PARAM'],\n      pano = this.pano_;\n  if (angleX) {\n    pano.control(povFlags['PITCH'], angleX);\n  }\n  if (angleY) {\n    pano.control(povFlags['HEADING'], angleY);\n  }\n  if (zoom) {\n    pano.control(povFlags['ZOOM'], zoom);\n  }\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.endControl = function(\n    opt_preventKinetics) {\n  'use strict';\n  this.pano_.endControl();\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.startInteraction = function(\n    modifiers, opt_kinetics) {\n  'use strict';\n  this.pano_.endControl();\n  this.pano_.endInteraction(H.util.shims.now());\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.interaction = function(x, y,\n    opt_bx, opt_by, opt_timestamp) {\n  'use strict';\n  var isBifocal = this.isBifocalInteraction(x, y, opt_bx, opt_by),\n      currentDistance = null,\n      currentFov,\n      fovToSet;\n\n  if (!this.interactionStarted_) {\n    this.interactionStarted_ = true;\n    this.pano_.beginInteraction(H.util.shims.now(), x, y);\n  }\n\n  if (isBifocal) {\n    currentFov = this.pano_.getZoom();\n    currentDistance = (new H.math.Point(x, y)).distance(/** @type {H.math.IPoint} */({\n      'x': opt_bx,\n      'y': opt_by\n    }));\n    if (this.pointDistance_ && this.pointDistance_ !== currentDistance) {\n      //using 0.2 as factor for changing fov until we'll figure out some\n      //more meaningfull math\n      fovToSet = currentFov - (currentDistance - this.pointDistance_) * 0.2;\n      this.distance_ = H.lang.UNDEF;\n      this.pano_.setZoom(H.math.clamp(fovToSet, this.fovMin_, this.fovMax_));\n      this.wasChangingFov_ = true;\n    }\n  } else {\n    /*\n     * This will prevent calling interact just after fov change\n     * it looks like there is a bug in pano which causes 'fov'\n     * to return to initial state from start of the interaction\n     * if 'interaction' is called after changing fov (looks like\n     * pano stores fov state and interaction start)\n     */\n    if (this.wasChangingFov_) {\n      this.wasChangingFov_ = false;\n      this.pano_.endInteraction();\n      //start new interaction (see above)\n      this.pano_.beginInteraction(H.util.shims.now(), x, y);\n    }\n    this.pano_.interact(opt_timestamp || H.util.shims.now(), x, y);\n  }\n\n  this.pointDistance_ = currentDistance;\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.endInteraction = function(\n    opt_preventKinetics) {\n  'use strict';\n  this.interactionStarted_ = false;\n  this.pano_.endInteraction(H.util.shims.now());\n  this.pointDistance_ = null;\n};\n\n\n/**\n * @param {number} zoom\n * @param {number=} opt_x\n * @param {number=} opt_y\n */\nH.map.render.panorama.RenderEngine.prototype.zoomAt = function(zoom, opt_x, opt_y) {\n  'use strict';\n  // this.pano_.setZoom(zoom);\n};\n\n\n/**\n * @override\n */\nH.map.render.panorama.RenderEngine.prototype.onResize = function() {\n  'use strict';\n  this.pano_.resize(this.viewPort['width'], this.viewPort['height']);\n};\n\n\n/**\n * @protected\n */\nH.map.render.panorama.RenderEngine.prototype.disposeInternal = function() {\n  'use strict';\n  var pano = this.pano_;\n  pano.removeEventListener(H.map.render.panorama.RenderEngine.POV_CHANGED_, this.synchronize_);\n  pano.removeEventListener(H.map.render.panorama.RenderEngine.POV_CHANGED_, this.rendered_);\n  pano.shutdown();\n  H.map.render.p2d.RenderEngine.superClass_.\n      disposeInternal.call(this);\n};\n\n\n/**\n * Function synchronizes current engine values with the view model\n * @param {Object} ev\n * @private\n */\nH.map.render.panorama.RenderEngine.prototype.synchronize_ = function(ev) {\n  'use strict';\n  var pano = this.pano_;\n  if (!this.exitState_) {\n    this.viewModel.synchronize(/** @type {H.map.ViewModel.CameraData}*/ ({\n      'position': pano.getPosition(),\n      'pitch': pano.getPitch(),\n      'yaw': pano.getHeading(),\n      'fov': pano.getZoom(),\n      'zoom': this.ZOOM_VALUE /** pano.getZoom() */\n    }));\n  }\n};\n\n\n/**\n * @param {Object} ev\n * @private\n */\nH.map.render.panorama.RenderEngine.prototype.rendered_ = function(ev) {\n  'use strict';\n  if (ev['isFinal']) {\n    this.dispatchEvent(this.EventType.RENDER);\n  }\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.screenToGeo = function(x, y) {\n  'use strict';\n  return /** @type {H.geo.IPoint} */ (this.pano_.pixelToGeo(\n      /** @type {H.PanoramaUtil.types.Point} */({'x': x, 'y': y}))\n  );\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.geoToScreen = function(point) {\n  'use strict';\n  return /** @type {H.math.IPoint} */ (this.pano_.geoToPixel(\n      /** @type {H.PanoramaUtil.types.LatLng} */ (point)));\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.screenToCameraData =\n    function(x, y) {\n  'use strict';\n  return /** @type {H.map.ViewModel.CameraData} */ (this.povToCamera_(\n      this.pano_.pixelToPov(/** @type {H.PanoramaUtil.types.Point} */({'x': x, 'y': y}))\n      ));\n};\n\n\n/**\n * @protected\n * @param {H.map.ViewModel.UpdateEvent} ev\n */\nH.map.render.panorama.RenderEngine.prototype.onViewUpdate = function(ev) {\n  'use strict';\n  var camera = ev['requested']['camera'],\n      fov = camera['fov'];\n  // it's impossible to change fov and preserve distance remove distance if fov changed\n  if (this.lastFov_ !== fov) {\n    this.distance_ = H.lang.UNDEF;\n  }\n  if (fov) {\n    this.pano_.setZoom(H.math.clamp(fov, this.fovMin_, this.fovMax_));\n    this.lastFov_ = fov;\n  }\n\n  this.pano_.moveTo(this.cameraToPov_(camera));\n};\n\n\n/**\n * Method convers camera to panorama specific PoV object\n * @param {Object} camera\n * @return {H.PanoramaUtil.types.Panorama}\n * @private\n */\nH.map.render.panorama.RenderEngine.prototype.cameraToPov_ =\n    function(camera) {\n  'use strict';\n  return /** @type {H.PanoramaUtil.types.Panorama} */({\n    'position': camera['position'],\n    'pitch': camera['pitch'],\n    'heading': camera['yaw'],\n    // restore distance saved in povToCamera_\n    'distance': this.distance_\n  });\n};\n\n\n/**\n * Method coverts panorama specific PoV object into camera\n * @param {Object} pov\n * @private\n * @return {Object}\n */\nH.map.render.panorama.RenderEngine.prototype.povToCamera_ = function(pov) {\n  'use strict';\n  // distance is important only in street level context, store it\n  this.distance_ = pov['distance'];\n  return {\n    'fov': this.pano_.getZoom(),\n    'position': pov['position'],\n    'pitch': pov['pitch'],\n    'yaw': pov['heading']\n  };\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.getBBox = function(type, margin) {\n  'use strict';\n  var position = /** @type {H.geo.IPoint} */ (this.pano_.getPosition());\n  // TODO StreetView has no functionality to request the covered area\n  //      The Quick'n'Dirty Fix for now is to just create a collapsed geo.Rect at camera position:\n  return H.geo.Rect.fromPoints(position, position);\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.getObjectsAt = function() {\n  'use strict';\n  return [];\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.getCapabilities = function() {\n  'use strict';\n  var pano = this.pano_;\n  return this.capabilities_;\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.setPointer = function(x, y) {\n  'use strict';\n  this.pano_.setPointer(x, y);\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.enter = function() {\n  'use strict';\n  this.pano_.enter(0, H.util.doNothing);\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.getCamForBounds = function() {\n  'use strict';\n  // TODO As soon as we have a CameraModel which contains zoom, we have to adjust the return type to CameraModel\n  return ({\n    'zoom': this.capabilities_.zoom.max,\n    'position': /** @type {H.geo.IPoint} */ (this.pano_.getPosition())\n  });\n};\n\n\n/**\n * @override\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.exit = function(callback) {\n  'use strict';\n  var that = this,\n      panoContainer = that.panoContainer_;\n  // increase panorama container's z-index in case if other engine's element has z-indexed elements,\n  // ex. dom markers\n  panoContainer.style.zIndex = 1000;\n  that.exitState_ = true;\n  that.pano_.exit(0, function() {\n    that.fadeout(panoContainer, function() {\n      callback();\n      panoContainer.parentNode.removeChild(panoContainer);\n    });\n  });\n};\n\n\n/**\n * Method returns the id of the currently displayed panorama.\n * @return {string} panorama id or empty string if no panorama is not loaded\n * @publish\n * @export\n */\nH.map.render.panorama.RenderEngine.prototype.getPanoramaId = function() {\n  'use strict';\n  return this.pano_.getPanoramaId();\n};\n\n\n/**\n * The type represents object that desccribes minimum set of data for panorama.\n * @typedef {{\n *   id: number,\n *   position: H.geo.IPoint\n * }}\n * @property {number} id unique panorama identifier\n * @property {position} position position of the given panorama\n * @publish\n */\nH.map.render.panorama.RenderEngine.Panorama;\n",
		"goog.provide('H.lang');\n\n\ngoog.require('goog.object');\ngoog.require('H.global');\n\n\n/**\n * Contains implementation for the base library definitions and error handling\n * @namespace H.lang\n * @publish\n */\n\n\n/**\n * This function uses prototype inheritance for provided\n * object constructors. Child constructor receives\n * parent's prototype methods.\n * @method\n * @param {Function} child\n * @param {Function} parent\n *\n * @example\n * function Parent(name){\n *   this.name = name;\n * };\n * Parent.prototype.printName = function(){\n *   console.log(this.name);\n * };\n *\n * function Child(name){\n *   Parent.call(this, name);\n * };\n * H.lang.inherits(Child, Parent);\n *\n * var childInstance = new Child('John');\n * childInstance.printName(); //method is available and will print name\n *\n * @export\n */\nH.lang.inherits =\n    goog.inherits; // new line, otherwise linter doesn't let it through otherwise :(\n\n\n/**\n * Extends an object with another object. This operates 'in-place'; it does not create a new Object.\n *\n * Example:\n * var o = {};\n * H.lang.extend(o, {a: 0, b: 1});\n * o; // {a: 0, b: 1}\n * H.lang.extend(o, {c: 2}, {d: 3});\n * o; // {a: 0, b: 1, c: 2, d: 3}\n *\n * @param {Object} target  The object to modify.\n * @param {...Object} var_args The objects from which values will be copied.\n *\n * @method\n * @export\n */\nH.lang.extend = goog.object.extend;\n\n\n/**\n * This function binds provided method to\n * given context. Which means whenever function will\n * be executed 'this' will point to provided context.\n * @method\n * @param {Function} func\n * @param {Object} ctx\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} a new function which is bound to the provided context\n *\n * @export\n */\nH.lang.bind = goog.bind;\n\n\n/**\n * A reference to the global String function, used for code size optimization\n * @type {function(?)}\n */\nH.lang.String = String;\n\n\n/**\n * A helper function to evaluate any kind of code without be boothered by CC\n * @private\n * @param {*=} opt_code\n * @return {*} the evalueated code\n */\nH.lang.evaluate_ = function(opt_code) {\n  return eval('' + opt_code);\n};\n\n\n//#################################################### CONSTANTS #######################################################\n\n\n/**\n * The \"eval('')\" prevents CC to \"optimize\" references to H.lang.UNDEF with \"void 0\"\n * @const\n * @type {undefined}\n */\nH.lang.UNDEF = /** @type {undefined} */ (H.lang.evaluate_());\n\n\n/**\n * The \"eval(null)\" prevents CC to \"optimize\" references to H.lang.NULL with \"null\"\n * @const\n * @type {null}\n */\nH.lang.NULL = /** @type {null} */ (H.lang.evaluate_(null));\n\n\n//################################################# CUSTOM TYPE DEFS ###################################################\n\n\n/**\n * An object which looks like an Array by having a 'length' property and entries accessible by an index.\n * @typedef {string|Array|NodeList|Arguments|{length: number}}\n */\nH.lang.ArrayLike;\n\n\n/**\n * A NumberLike defines an object that can be converted to a number by operating\n * on it using number operators (+, -, etc.).\n * @typedef {number|string}\n */\nH.lang.NumberLike;\n\n\n/**\n * Represents a truthy or falsy value. The value is evaluated by use of double negation {@code !!value}\n *\n * @typedef {?}\n */\nH.lang.Booly;\n\n\n/**\n * Splits the specified string into tokens\n * @export\n * @param {*} val The value to split it's string representation\n * @param {(string|RegExp)=} opt_delimiter The delimiter to use for splitting, if omitted a space is used\n * @return {Array.<string>} the list of tokens\n */\nH.lang.tokenize = function(val, opt_delimiter) {\n  return H.lang.String(val).split(opt_delimiter !== H.lang.UNDEF ? opt_delimiter : ' ');\n};\n\n\n//############################################# REFLECTION RELATED STUFF ###############################################\n\n\n/**\n * The names of the fields that are defined on Object.prototype.\n * @const\n * @type {Array.<string>}\n */\nH.lang.PROTOTYPEFIELDS = [\n  'prototype',\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/**\n * Checks whether the given value is an instance of the given constructor.\n * If not so and the optional caller is specified, an InvalidArgumentError is thrown\n * @throws {H.lang.InvalidArgumentError}\n * @param {*} value The value to test.\n * @param {!Function} cstr The constructor to test against.\n * @param {Function=} opt_caller The caller to use for the error\n * @param {number=} opt_argNr The argument number to use for the error\n * @param {*=} opt_message The message to use for the error\n * @return {boolean} Whether the value is an instance of the constructor\n */\nH.lang.isInstanceOf = function(value, cstr, opt_caller, opt_argNr, opt_message) {\n  'use strict';\n  var isInstanceOf;\n  if (!(isInstanceOf = value instanceof cstr) && opt_caller) {\n    throw new H.lang.InvalidArgumentError(\n        opt_caller, opt_argNr, H.lang.isDef(opt_message) ? opt_message : value);\n  }\n  return isInstanceOf;\n};\n\n\n/**\n * Returns true if the value's constructor is identical with the specified constructor\n * @param {*} value The value to test.\n * @param {!Function} cstr The constructor to test against.\n * @return {boolean} Whether the value's constructor is identical\n */\nH.lang.isConstructedBy = function(value, cstr) {\n  'use strict';\n  return H.lang.isInstanceOf(value, cstr) && value.constructor === cstr;\n};\n\n\n/**\n * It checks the constructor of the given instance and the given constructor for identity. If the result of this check\n * not equals the opt_expected value a TypeError with the message \"Illegal constructor\" and the name of the constructor\n * symbol is thrown.\n *\n * @example\n *   MyAbstractClass = function() {\n *     H.lang.checkIllegalConstructor(this, MyAbstractClass, false);\n *   };\n *   MyFinalClass = function() {\n *     H.lang.checkIllegalConstructor(this, MyFinalClass, true);\n *     MyFinalClass.superClass_.constructor.call(this);\n *   };\n *   goog.inherits(MyFinalClass, MyAbstractClass);\n *   MyClass = function() {\n *     MyClass.superClass_.constructor.call(this);\n *   };\n *   goog.inherits(MyClass, MyFinalClass);\n *\n *   new MyAbstractClass(); // TypeError - You can't instatiate an abstract class\n *   new MyFinalClass();\n *   new MyClass();         // TypeError - You can't extend a final class\n *\n *\n * @throws {TypeError}\n * @param {*} instance The instance to check\n * @param {!Function} constructor The construtor to check against\n * @param {boolean=} opt_expected The expected result of the identity-check, default is {@code false}\n */\nH.lang.checkIllegalConstructor = function(instance, constructor, opt_expected) {\n  if (H.lang.isConstructedBy(instance, constructor) === !opt_expected) {\n    throw new TypeError('Illegal constructor' + ' ' + H.lang.getSymbolPath(constructor));\n  }\n};\n\n\n/**\n * Returns true if the specified value is a function\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is a function.\n */\nH.lang.isFunction = goog.isFunction;\n\n\n/**\n * Determines if the given value is an object\n *\n * @param {*} val The value to test\n * @return {boolean}\n */\nH.lang.isObject = goog.isObject;\n\n\n/**\n * Returns true if the specified value is |null|\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is null.\n */\nH.lang.isNull = goog.isNull;\n\n\n/**\n * Returns true if the object looks like an array. To qualify as array like\n * the value needs to be either a NodeList or an object with a Number length\n * property.\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is an array.\n */\nH.lang.isArrayLike = goog.isArrayLike;\n\n\n/**\n * Checks whether H.lang.typeof() produces for the given value the given type.\n * If not so and the optional caller is specified, an InvalidArgumentError is thrown\n * @throws {H.lang.InvalidArgumentError}\n * @param {*} value The value to test.\n * @param {!string} type The type to test against.\n * @param {Function=} opt_caller The caller to use for the error\n * @param {number=} opt_argNr The argument number to use for the error\n * @param {*=} opt_message The message to use for the error\n * @return {boolean} Whether the value is of the expected type\n */\nH.lang.isTypeOf = function(value, type, opt_caller, opt_argNr, opt_message) {\n  'use strict';\n  var isTypeOf;\n  if (!(isTypeOf = H.lang.typeOf(value) === type) && opt_caller) {\n    throw new H.lang.InvalidArgumentError(\n        opt_caller, opt_argNr, H.lang.isDef(opt_message) ? opt_message : value);\n  }\n  return isTypeOf;\n};\n\n\n/**\n * Checks whether the given value is of type Array.\n * If not so and the optional caller is specified, an InvalidArgumentError is thrown\n * @throws {H.lang.InvalidArgumentError}\n * @param {*} value The value to test.\n * @param {Function=} opt_caller The caller to use for the error\n * @param {number=} opt_argNr The argument number to use for the error\n * @param {*=} opt_message The message to use for the error\n * @return {boolean} Whether the value is of type Array\n */\nH.lang.isArray = function(value, opt_caller, opt_argNr, opt_message) {\n  'use strict';\n  return H.lang.isTypeOf(value, 'Array', opt_caller, opt_argNr, opt_message);\n};\n\n\n/**\n * Returns true if the specified value is not |undefined|.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is defined.\n */\nH.lang.isDef = function(val) {\n  // We are not using goog.isDef code because it assumes that the global undefined variable has not been redefined\n  //return val !== undefined;\n  return val !== H.lang.UNDEF;\n};\n\n\n/**\n * Returns true if the specified value is defined and not null\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is defined and not null.\n */\nH.lang.isDefAndNotNull = goog.isDefAndNotNull;\n\n\n/**\n * Returns true if the specified value is a string\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is a string.\n */\nH.lang.isString = goog.isString;\n\n\n/** @ignore */\nH.lang.parseInt = parseInt;\n\n\n/** @ignore */\nH.lang.parseFloat = parseFloat;\n\n\n/** @ignore */\nH.lang.isNaN = isNaN;\n\n\n/**\n * Returns true if the specified value is a number\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is a number.\n */\nH.lang.isNumber = function(val) {\n  // We are stricter than goog.isNumber(), because we also check !isNaN(val)\n  return val === + /** @type {number} */ (val);\n};\n\n\n/**\n * Returns true if the specified value is number like, a type whose valueOf or toString returns a (parseable) number\n * but not NaN. Examples: null, [ ], '4711', '47e11', '0xFF', new Date, '' etc.\n * @param {*} val The value to test.\n * @return {boolean} Whether variable is number like.\n */\nH.lang.isNumberLike = function(val) {\n  return !H.lang.isNaN(+ /**@type {number} */ (val));\n};\n\n\n/**\n * Determines the type of a value\n *\n * @param {*} val The value to reflect\n * @return {string} The type name of the value\n */\nH.lang.typeOf = function(val) {\n  'use strict';\n  var str = Object[H.lang.PROTOTYPEFIELDS[0]][H.lang.PROTOTYPEFIELDS[6]].call(/** @type {Object} */ (val)),\n      match = str.match(/^\\[object (\\w+)\\]$/);\n  // Google Chrome v31 produces '[object global]' for window objects:\n  return match ? match[1] : typeof val;\n};\n\n\n//######################################### DEBUG RELATED FUNCTIONALITY ################################################\n\n\nif (goog.DEBUG) {\n\n\n  /**\n   * A flag disbale expensive symbol path detection during {@link H.lang.getSymbolPath} calls.\n   * It's automatially set to {@code true} if goog.DEBUG flag is set and jasmine is running.\n   * To enable symbol path detection set the value to {@code false}\n   * @type {boolean}\n   */\n  H.lang.NO_SYMBOLS = !!H.global['jasmine'];\n  // The try catch is needed for IE9:\n  try {\n    H.global.console.warn('DEBUG', H.lang.NO_SYMBOLS ? '/ NO_SYMBOLS' : '');\n  } catch (e) {}\n}\n\n\n/**\n * Determines for a given object the symbol path within H namespace\n * The optional arguments opt_namespace, opt_path and opt_passed MUST NOT passed in initial call, because they are\n * internally used for recursive calls only!\n *\n * @example\n * H.lang.InvalidArgumentError.getNamespace(H.map.Polyline); // ==> 'H.map.Polyline'\n * H.lang.InvalidArgumentError.getNamespace(function(){});        // ==> '~Function'\n *\n * @param {*} object The object to reflect\n * @param {(Object|Function)=} opt_namespace The namespace to reflect\n * @param {string=} opt_path The path to the namespace\n * @param {(Array.<*>)=} opt_passed The list of already passed namespaces\n * @return {string} The determined symbol path or an empty string if symbol clouldn't found\n */\nH.lang.getSymbolPath = function(object, opt_namespace, opt_path, opt_passed) {\n  'use strict';\n  var path = '',\n      initialCall = arguments.length < 2;\n  // Initial call? Define the initial optional arguments:\n  if (initialCall) {\n    // WTF: With \"{'H': H}\" CC says \"incomplete alias created for namespace H\"\n    opt_namespace = H.lang.NO_SYMBOLS ? {} : {'H': H.global['H']};\n    opt_path = '';\n    opt_passed = [];\n  }\n  H.lang.forEachProp(opt_namespace, true, function(obj, key) {\n    var val = obj[key];\n    // Try to adjust the key to the non obfuscated (exported) key:\n    key = H.lang.propertyNameByValue(obj, val);\n    // Ignore window objects and DOM nodes:\n    if (!H.lang.isWindow(val) && !H.lang.isNode(val)) {\n      // Ignore all types other than 'object' and 'function':\n      if (H.lang.isObject(val)) {\n        // Check if we found the requested object:\n        if (val === object) {\n          path = opt_path + '.' + key;\n          return true; // stops forEachProp_\n        }\n        // Ignore already passed objects:\n        if (opt_passed.indexOf(val) < 0) {\n          // Register the value as 'passed' to prevent recursion for circular references:\n          opt_passed.push(val);\n          // Recursive call with the current property value and extended path:\n          path = H.lang.getSymbolPath(object, val,\n              opt_path + '.' + key,\n              opt_passed);\n          if (path) {\n            return true; // stops forEachProp_\n          }\n        }\n      }\n    }\n  });\n\n  if (initialCall) {\n    path = path ?\n        // Remove the leading '.' and replace 'Foo.prototype.bar' with 'Foo#bar':\n        path.substr(1).replace('.' + H.lang.PROTOTYPEFIELDS[0] + '.', '#') :\n        '~' + (\n            H.lang.isFunction(object) ?\n            H.lang.getFunctionName(/** @type {Function} */ (object)) + '()' :\n            H.lang.typeOf(object));\n  }\n  return path;\n};\n\n\n/**\n * Determines if the given value is a Window object\n *\n * @param {*} val The value to reflect\n * @return {boolean}\n */\nH.lang.isWindow = function(val) {\n  'use strict';\n  return H.lang.isObject(val) && val['window'] === val && val['self'] === val;\n};\n\n\n/**\n * Determines if the given value is a Document object\n *\n * @param {*} val The value to reflect\n * @return {boolean}\n */\nH.lang.isNode = function(val) {\n  'use strict';\n  return H.lang.isObject(val) && val['nodeType'] > 0 && H.lang.isFunction(val.cloneNode);\n};\n\n\n/**\n * Detects the identifier of the first property which was found in the given object.\n * It's useful if there is a need to select a property via bracket notation (like myObject[myKey]) but the\n * property identifier was possibly renamed by Closure Compiler.\n * You can also use @link{H.lang.propertyNameByValue} if the property's value is unique within the object and\n * it's whole prototype chain.\n *\n * @example\n * myCar = {color: 'red', doors: 5}; // ==> compiled to e.g. 'x = {m: 'red', o: 5};'\n * colorKey = H.lang.firstOwnPropertyName({color:0}); // ==> 'm'\n * for(key in myObject) {\n *   if(key === colorKey) alert('A ' + myObject[key] + ' Car');  // ==> \"A red Car\"\n * }\n *\n * @param {!Object} object\n * @return {string|undefined}\n */\nH.lang.firstOwnPropertyName = function(object) {\n  'use strict';\n  var firstPropertyName;\n  H.lang.forEachProp(object, true, function(obj, key) {\n    firstPropertyName = key;\n    return true;\n  });\n  return firstPropertyName;\n};\n\n\n/**\n * Tries to find the identifier of the property which references an identical value. If more than one property found,\n * the one with the longest name is taken (typically the non obfuscated exported one).\n * Returns undefined if no property was found which references the given value.\n *\n * @example\n * Cat.prototype.hello = function() { this.say_(); }; // ==> 'hello' compiled to 'a', but also exported as 'hello'\n * Cat.prototype.say_ = function() {\n *   alert(H.lang.propertyNameByValue(this, arguments.callee.caller) // ==> 'hello'\n * };\n *\n * @param {Object|Function} object\n * @param {Object|Function} value\n * @param {boolean=} opt_onlyOwnProperties If set to {@code true} prototype properties are ignored\n * @return {string|undefined}\n */\nH.lang.propertyNameByValue = function(object, value, opt_onlyOwnProperties) {\n  'use strict';\n  var keys = [];\n  H.lang.forEachProp(object, !!opt_onlyOwnProperties, function(obj, key) {\n    if (obj[key] === value) {\n      keys.push(key);\n    }\n  });\n  return keys.sort(H.lang.sortByLength)[0];\n};\n\n\n/**\n * To sort a list of array like objects by length in descending order.\n *\n * @param {H.lang.ArrayLike} a\n * @param {H.lang.ArrayLike} b\n * @return {number}\n */\nH.lang.sortByLength = function(a, b) {\n  'use strict';\n  return b.length - a.length;\n};\n\n\n/**\n * Iterates over the object calling the supplied callback once for each property.\n * @export\n * @param {?(Object|undefined)} obj\n * @param {boolean} onlyOwnProperties If set to {@code true} prototype properties are ignored\n * @param {function(Object, string, boolean): ?} callback The function to invoke.\n *      It gets the iterated object, the current property key and an isEnumerable flag as arguments.\n *      If the callback's return value evaluates to {@code true} the iteration stops\n */\nH.lang.forEachProp = function(obj, onlyOwnProperties, callback) {\n  'use strict';\n  var key,\n      i;\n  if (obj) {\n    for (key in obj) {\n      if (!onlyOwnProperties || obj[H.lang.PROTOTYPEFIELDS[2]](key)) {\n        if (callback(obj, key, true)) {\n          return;\n        }\n      }\n    }\n    i = H.lang.PROTOTYPEFIELDS.length;\n    while (i--) {\n      key = H.lang.PROTOTYPEFIELDS[i];\n      if (!onlyOwnProperties || obj[H.lang.PROTOTYPEFIELDS[2]](key)) {\n        if (callback(obj, key, false)) {\n          return;\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * Creates a JSDOC like separator symbol for a property\n *\n * @example\n * H.lang.propertyRelation([], 'length'); // '^'  ==> length is a instance property of an Array instance\n * H.lang.propertyRelation([], 'splice'); // '#'  ==> splice is a prototype property of an Array instance\n * H.lang.propertyRelation(RegExp, '$1'); // '.'  ==> $1 is a static property of the RegExp class\n * H.lang.propertyRelation({}, {});       // '~'  ==> no relation between the given objects\n *\n * @param {?Object} object\n * @param {string|undefined} key The key of the property\n * @return {string|undefined} The according property type '^' for instance, '.' for static, '#' for prototype\n *       or {@code undefined} if the property couldn't found\n */\nH.lang.propertyRelation = function(object, key) {\n  'use strict';\n  var cstr;\n  return object && key !== undefined && H.lang.isObject(object) && key in object ?\n      object[H.lang.PROTOTYPEFIELDS[2]](key) ?\n          // The object's constructor is neither Object nor Function:\n          (cstr = object[H.lang.PROTOTYPEFIELDS[1]]) !== Object && cstr !== Function ?\n              '^' :     // instance property\n              '.' :     // static property\n          '#' :         // prototype property\n      '~';              // no relation (e.g. a function in scope of a class method)\n};\n\n\n//############################################# SOURCE CODE DEBUG HELPERS ##############################################\n\n\n/**\n * Determines the name of a function\n *\n * @param {Function} func\n * @return {string} The function's name or \"anonymous\"\n */\nH.lang.getFunctionName = function(func) {\n  'use strict';\n  var matches = /^\\s*function ([^\\( ]+)/.exec(func);\n  return matches ? matches[1] : 'anonymous';\n};\n\n\n/**\n * Removes the comments from a source code\n *\n * @param {*} sourceCode\n * @return {string} The source code without comments\n */\nH.lang.dropComments = function(sourceCode) {\n  'use strict';\n  return ('' + sourceCode).replace(/(\\/\\*([\\s\\S]*?)\\*\\/)|(\\/\\/(.*)$)/gm, '');\n};\n\n\n/**\n * Renames the given argument names to '#0', '#1', #2' ...\n *\n * @param {string} name\n * @param {number} idx\n * @param {Array.<string>} argumentNames\n */\nH.lang.numberedArguments = function(name, idx, argumentNames) {\n  'use strict';\n  argumentNames[idx] = '#' + idx;\n};\n\n\n/**\n * Determines the argument names of a function.\n *\n * @param {Function} func\n * @return {Array.<string>} the argument names. If COMPILED is true the obfuscated names are replaces by '#0', '#1' ...\n */\nH.lang.getArgumentNames = function(func) {\n  'use strict';\n  var matches = /.*\\(([^\\)]+)/.exec(H.lang.dropComments(func));\n  matches = matches ? H.lang.tokenize(matches[1].replace(/\\s+/g, ''), ',') : [];\n  if (COMPILED) {\n    matches.forEach(H.lang.numberedArguments);\n  }\n  return matches;\n};\n\n\n/**\n * Function warns the user that a symbol has been\n * deprecated and it will be removed soon.\n * @param {*} symbol symbol function name or object which will be deprecated\n * @param {string=} opt_message optional additional message i.e describing alternative\n */\nH.lang.deprecated = function(symbol, opt_message) {\n  'use strict';\n  var console = H.global['console'],\n      message;\n  if (console && console['warn']) {\n    message = H.lang.getSymbolPath(symbol) + ' is deprecated and will be removed soon. ';\n    if (opt_message) {\n      message += opt_message;\n    }\n    console['warn'](message);\n  }\n};\n\n\n\n",
		"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will write out Closure's deps file, unless the\n * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to\n * include their own deps file(s) from different locations.\n *\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler when --closure_pass\n *     or --mark_as_compiled is specified.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is\n * already defined in the current scope before assigning to prevent\n * clobbering if base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {}; // Identifies this file as the Closure base.\n\n\n/**\n * Reference to the global context.  In most cases this will be 'window'.\n */\ngoog.global = this;\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production js_binary can be easily stripped\n * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most\n * toString() methods should be declared inside an \"if (goog.DEBUG)\" conditional\n * because they are generally used for debugging purposes and it is difficult\n * for the JSCompiler to statically determine whether they are used.\n */\ngoog.DEBUG = true;\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as JSCompiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.\n */\ngoog.LOCALE = 'en';  // default to en\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your javascript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the JSCompiler.\n */\ngoog.TRUSTED_SITE = true;\n\n\n/**\n * Creates object stubs for a namespace.  The presence of one or more\n * goog.provide() calls indicate that the file defines the given\n * objects/namespaces.  Build tools also scan for provide/require statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n * @see goog.require\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n */\ngoog.provide = function(name) {\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice. This is intended\n    // to teach new developers that 'goog.provide' is effectively a variable\n    // declaration. And when JSCompiler transforms goog.provide into a real\n    // variable declaration, the compiled JS should work the same as the raw\n    // JS--even when the raw JS uses goog.provide incorrectly.\n    if (goog.isProvided_(name)) {\n      throw Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name);\n};\n\n\n/**\n * Marks that the current file should only be used for testing, and never for\n * live code in production.\n *\n * In the case of unit tests, the message may optionally be an exact\n * namespace for the test (e.g. 'goog.stringTest'). The linter will then\n * ignore the extra provide (if not explicitly defined in the code).\n *\n * @param {string=} opt_message Optional message to add to the error that's\n *     raised when used in production code.\n */\ngoog.setTestOnly = function(opt_message) {\n  if (COMPILED && !goog.DEBUG) {\n    opt_message = opt_message || '';\n    throw Error('Importing test-only code into non-debug environment' +\n                opt_message ? ': ' + opt_message : '.');\n  }\n};\n\n\nif (!COMPILED) {\n\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares\n   * that 'goog' and 'goog.events' must be namespaces.\n   *\n   * @type {Object}\n   * @private\n   */\n  goog.implicitNamespaces_ = {};\n}\n\n\n/**\n * Builds an object structure for the provided namespace path,\n * ensuring that names that already exist are not overwritten. For\n * example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name name of the object that this file defines.\n * @param {*=} opt_object the object to expose at the end of the path.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n * @private\n */\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\n  var parts = name.split('.');\n  var cur = opt_objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && cur.execScript) {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  // Certain browsers cannot parse code in the form for((a in b); c;);\n  // This pattern is produced by the JSCompiler when it collapses the\n  // statement above into the conditional loop below. To prevent this from\n  // happening, use a for-loop and reserve the init logic as below.\n\n  // Parentheses added to eliminate strict JS warning in Firefox.\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && goog.isDef(opt_object)) {\n      // last part and we have an object; use it\n      cur[part] = opt_object;\n    } else if (cur[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Returns an object based on its fully qualified external name.  If you are\n * using a compilation pass that renames property names beware that using this\n * function will not find renamed properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} opt_obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, opt_obj) {\n  var parts = name.split('.');\n  var cur = opt_obj || goog.global;\n  for (var part; part = parts.shift(); ) {\n    if (goog.isDefAndNotNull(cur[part])) {\n      cur = cur[part];\n    } else {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Globalizes a whole namespace, such as goog or goog.lang.\n *\n * @param {Object} obj The namespace to globalize.\n * @param {Object=} opt_global The object to add the properties to.\n * @deprecated Properties may be explicitly exported to the global scope, but\n *     this should no longer be done in bulk.\n */\ngoog.globalize = function(obj, opt_global) {\n  var global = opt_global || goog.global;\n  for (var x in obj) {\n    global[x] = obj[x];\n  }\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {Array} provides An array of strings with the names of the objects\n *                         this file provides.\n * @param {Array} requires An array of strings with the names of the objects\n *                         this file requires.\n */\ngoog.addDependency = function(relPath, provides, requires) {\n  if (!COMPILED) {\n    var provide, require;\n    var path = relPath.replace(/\\\\/g, '/');\n    var deps = goog.dependencies_;\n    for (var i = 0; provide = provides[i]; i++) {\n      deps.nameToPath[provide] = path;\n      if (!(path in deps.pathToNames)) {\n        deps.pathToNames[path] = {};\n      }\n      deps.pathToNames[path][provide] = true;\n    }\n    for (var j = 0; require = requires[j]; j++) {\n      if (!(path in deps.requires)) {\n        deps.requires[path] = {};\n      }\n      deps.requires[path][require] = true;\n    }\n  }\n};\n\n\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an orignal\n// way to do \"debug-mode\" development.  The dependency system can sometimes\n// be confusing, as can the debug DOM loader's asyncronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the\n// script will not load until some point after the current script.  If a\n// namespace is needed at runtime, it needs to be defined in a previous\n// script, or loaded via require() with its registered dependencies.\n// User-defined namespaces may need their own deps file.  See http://go/js_deps,\n// http://go/genjsdeps, or, externally, DepsWriter.\n// http://code.google.com/closure/library/docs/depswriter.html\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work is being done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.ENABLE_DEBUG_LOADER = true;\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies\n * that works in parallel with the BUILD system. Note that all calls\n * to goog.require will be stripped by the JSCompiler when the\n * --closure_pass option is used.\n * @see goog.provide\n * @param {string} name Namespace to include (as was given in goog.provide())\n *     in the form \"goog.package.part\".\n */\ngoog.require = function(name) {\n\n  // if the object already exists we do not need do do anything\n  // TODO(arv): If we start to support require based on file name this has\n  //            to change\n  // TODO(arv): If we allow goog.foo.* this has to change\n  // TODO(arv): If we implement dynamic load after page load we should probably\n  //            not remove this code for the compiled output\n  if (!COMPILED) {\n    if (goog.isProvided_(name)) {\n      return;\n    }\n\n    if (goog.ENABLE_DEBUG_LOADER) {\n      var path = goog.getPathFromDeps_(name);\n      if (path) {\n        goog.included_[path] = true;\n        goog.writeScripts_();\n        return;\n      }\n    }\n\n    var errorMessage = 'goog.require could not find: ' + name;\n    if (goog.global.console) {\n      goog.global.console['error'](errorMessage);\n    }\n\n\n      throw Error(errorMessage);\n\n  }\n};\n\n\n/**\n * Path for included scripts\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to write out Closure's deps file. By default,\n * the deps are written.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The function is passed the script source, which is a relative URI. It should\n * return true if the script was imported, false otherwise.\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * Null function used for default values of callbacks, etc.\n * @return {void} Nothing.\n */\ngoog.nullFunction = function() {};\n\n\n/**\n * The identity function. Returns its first argument.\n *\n * @param {*=} opt_returnValue The single value that will be returned.\n * @param {...*} var_args Optional trailing arguments. These are ignored.\n * @return {?} The first argument. We can't know the type -- just pass it along\n *      without type.\n * @deprecated Use goog.functions.identity instead.\n */\ngoog.identityFunction = function(opt_returnValue, var_args) {\n  return opt_returnValue;\n};\n\n\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n *\n * Foo.prototype.bar = goog.abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error\n * will be thrown when bar() is invoked.\n *\n * Note: This does not take the name of the function to override as\n * an argument because that would make it more difficult to obfuscate\n * our JavaScript code.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be\n *   overridden.\n */\ngoog.abstractMethod = function() {\n  throw Error('unimplemented abstract method');\n};\n\n\n/**\n * Adds a {@code getInstance} static method that always return the same instance\n * object.\n * @param {!Function} ctor The constructor for the class to add the static\n *     method to.\n */\ngoog.addSingletonGetter = function(ctor) {\n  ctor.getInstance = function() {\n    if (ctor.instance_) {\n      return ctor.instance_;\n    }\n    if (goog.DEBUG) {\n      // NOTE: JSCompiler can't optimize away Array#push.\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\n    }\n    return ctor.instance_ = new ctor;\n  };\n};\n\n\n/**\n * All singleton classes that have been instantiated, for testing. Don't read\n * it directly, use the {@code goog.testing.singleton} module. The compiler\n * removes this variable if unused.\n * @type {!Array.<!Function>}\n * @private\n */\ngoog.instantiatedSingletons_ = [];\n\n\nif (!COMPILED && goog.ENABLE_DEBUG_LOADER) {\n  /**\n   * Object used to keep track of urls that have already been added. This\n   * record allows the prevention of circular dependencies.\n   * @type {Object}\n   * @private\n   */\n  goog.included_ = {};\n\n\n  /**\n   * This object is used to keep track of dependencies and other data that is\n   * used for loading scripts\n   * @private\n   * @type {Object}\n   */\n  goog.dependencies_ = {\n    pathToNames: {}, // 1 to many\n    nameToPath: {}, // 1 to 1\n    requires: {}, // 1 to many\n    // used when resolving dependencies to prevent us from\n    // visiting the file twice\n    visited: {},\n    written: {} // used to keep track of script files we have written\n  };\n\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    var doc = goog.global.document;\n    return typeof doc != 'undefined' &&\n           'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * Tries to detect the base path of the base.js script that bootstraps Closure\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.global.CLOSURE_BASE_PATH) {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    var doc = goog.global.document;\n    var scripts = doc.getElementsByTagName('script');\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var src = scripts[i].src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n\n  /**\n   * Imports a script if, and only if, that script hasn't already been imported.\n   * (Must be called at execution time)\n   * @param {string} src Script source.\n   * @private\n   */\n  goog.importScript_ = function(src) {\n    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||\n        goog.writeScriptTag_;\n    if (!goog.dependencies_.written[src] && importScript(src)) {\n      goog.dependencies_.written[src] = true;\n    }\n  };\n\n\n  /**\n   * The default implementation of the import function. Writes a script tag to\n   * import the script.\n   *\n   * @param {string} src The script source.\n   * @return {boolean} True if the script was imported, false otherwise.\n   * @private\n   */\n  goog.writeScriptTag_ = function(src) {\n    if (goog.inHtmlDocument_()) {\n      var doc = goog.global.document;\n\n      // If the user tries to require a new symbol after document load,\n      // something has gone terribly wrong. Doing a document.write would\n      // wipe out the page.\n      if (doc.readyState == 'complete') {\n        // Certain test frameworks load base.js multiple times, which tries\n        // to write deps.js each time. If that happens, just fail silently.\n        // These frameworks wipe the page between each load of base.js, so this\n        // is OK.\n        var isDeps = /\\bdeps.js$/.test(src);\n        if (isDeps) {\n          return false;\n        } else {\n          throw Error('Cannot write \"' + src + '\" after document load');\n        }\n      }\n\n      doc.write(\n          '<script type=\"text/javascript\" src=\"' + src + '\"></' + 'script>');\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n\n  /**\n   * Resolves dependencies based on the dependencies added using addDependency\n   * and calls importScript_ in the correct order.\n   * @private\n   */\n  goog.writeScripts_ = function() {\n    // the scripts we need to write this time\n    var scripts = [];\n    var seenScript = {};\n    var deps = goog.dependencies_;\n\n    function visitNode(path) {\n      if (path in deps.written) {\n        return;\n      }\n\n      // we have already visited this one. We can get here if we have cyclic\n      // dependencies\n      if (path in deps.visited) {\n        if (!(path in seenScript)) {\n          seenScript[path] = true;\n          scripts.push(path);\n        }\n        return;\n      }\n\n      deps.visited[path] = true;\n\n      if (path in deps.requires) {\n        for (var requireName in deps.requires[path]) {\n          // If the required name is defined, we assume that it was already\n          // bootstrapped by other means.\n          if (!goog.isProvided_(requireName)) {\n            if (requireName in deps.nameToPath) {\n              visitNode(deps.nameToPath[requireName]);\n            } else {\n              throw Error('Undefined nameToPath for ' + requireName);\n            }\n          }\n        }\n      }\n\n      if (!(path in seenScript)) {\n        seenScript[path] = true;\n        scripts.push(path);\n      }\n    }\n\n    for (var path in goog.included_) {\n      if (!deps.written[path]) {\n        visitNode(path);\n      }\n    }\n\n    for (var i = 0; i < scripts.length; i++) {\n      if (scripts[i]) {\n        goog.importScript_(goog.basePath + scripts[i]);\n      } else {\n        throw Error('Undefined script input');\n      }\n    }\n  };\n\n\n  /**\n   * Looks at the dependency rules and tries to determine the script file that\n   * fulfills a particular rule.\n   * @param {string} rule In the form goog.namespace.Class or project.script.\n   * @return {?string} Url corresponding to the rule, or null.\n   * @private\n   */\n  goog.getPathFromDeps_ = function(rule) {\n    if (rule in goog.dependencies_.nameToPath) {\n      return goog.dependencies_.nameToPath[rule];\n    } else {\n      return null;\n    }\n  };\n\n  goog.findBasePath_();\n\n  // Allow projects to manage the deps files themselves.\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.importScript_(goog.basePath + 'deps.js');\n  }\n}\n\n\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n * operator in such a way that null returns 'null' and arrays return 'array'.\n * @param {*} value The value to get the type of.\n * @return {string} The name of the type.\n */\ngoog.typeOf = function(value) {\n  var s = typeof value;\n  if (s == 'object') {\n    if (value) {\n      // Check these first, so we can avoid calling Object.prototype.toString if\n      // possible.\n      //\n      // IE improperly marshals tyepof across execution contexts, but a\n      // cross-context object will still return false for \"instanceof Object\".\n      if (value instanceof Array) {\n        return 'array';\n      } else if (value instanceof Object) {\n        return s;\n      }\n\n      // HACK: In order to use an Object prototype method on the arbitrary\n      //   value, the compiler requires the value be cast to type Object,\n      //   even though the ECMA spec explicitly allows it.\n      var className = Object.prototype.toString.call(\n          /** @type {Object} */ (value));\n      // In Firefox 3.6, attempting to access iframe window objects' length\n      // property throws an NS_ERROR_FAILURE, so we need to special-case it\n      // here.\n      if (className == '[object Window]') {\n        return 'object';\n      }\n\n      // We cannot always use constructor == Array or instanceof Array because\n      // different frames have different Array objects. In IE6, if the iframe\n      // where the array was created is destroyed, the array loses its\n      // prototype. Then dereferencing val.splice here throws an exception, so\n      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\n      // so that will work. In this case, this function will return false and\n      // most array functions will still work because the array is still\n      // array-like (supports length and []) even though it has lost its\n      // prototype.\n      // Mark Miller noticed that Object.prototype.toString\n      // allows access to the unforgeable [[Class]] property.\n      //  15.2.4.2 Object.prototype.toString ( )\n      //  When the toString method is called, the following steps are taken:\n      //      1. Get the [[Class]] property of this object.\n      //      2. Compute a string value by concatenating the three strings\n      //         \"[object \", Result(1), and \"]\".\n      //      3. Return Result(2).\n      // and this behavior survives the destruction of the execution context.\n      if ((className == '[object Array]' ||\n           // In IE all non value types are wrapped as objects across window\n           // boundaries (not iframe though) so we have to do object detection\n           // for this edge case\n           typeof value.length == 'number' &&\n           typeof value.splice != 'undefined' &&\n           typeof value.propertyIsEnumerable != 'undefined' &&\n           !value.propertyIsEnumerable('splice')\n\n          )) {\n        return 'array';\n      }\n      // HACK: There is still an array case that fails.\n      //     function ArrayImpostor() {}\n      //     ArrayImpostor.prototype = [];\n      //     var impostor = new ArrayImpostor;\n      // this can be fixed by getting rid of the fast path\n      // (value instanceof Array) and solely relying on\n      // (value && Object.prototype.toString.vall(value) === '[object Array]')\n      // but that would require many more function calls and is not warranted\n      // unless closure code is receiving objects from untrusted sources.\n\n      // IE in cross-window calls does not correctly marshal the function type\n      // (it appears just as an object) so we cannot use just typeof val ==\n      // 'function'. However, if the object has a call property, it is a\n      // function.\n      if ((className == '[object Function]' ||\n          typeof value.call != 'undefined' &&\n          typeof value.propertyIsEnumerable != 'undefined' &&\n          !value.propertyIsEnumerable('call'))) {\n        return 'function';\n      }\n\n\n    } else {\n      return 'null';\n    }\n\n  } else if (s == 'function' && typeof value.call == 'undefined') {\n    // In Safari typeof nodeList returns 'function', and on Firefox\n    // typeof behaves similarly for HTML{Applet,Embed,Object}Elements\n    // and RegExps.  We would like to return object for those and we can\n    // detect an invalid function by making sure that the function\n    // object has a call method.\n    return 'object';\n  }\n  return s;\n};\n\n\n/**\n * Returns true if the specified value is not |undefined|.\n * WARNING: Do not use this to test if an object has a property. Use the in\n * operator instead.  Additionally, this function assumes that the global\n * undefined variable has not been redefined.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\ngoog.isDef = function(val) {\n  return val !== undefined;\n};\n\n\n/**\n * Returns true if the specified value is |null|\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is null.\n */\ngoog.isNull = function(val) {\n  return val === null;\n};\n\n\n/**\n * Returns true if the specified value is defined and not null\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\ngoog.isDefAndNotNull = function(val) {\n  // Note that undefined == null.\n  return val != null;\n};\n\n\n/**\n * Returns true if the specified value is an array\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArray = function(val) {\n  return goog.typeOf(val) == 'array';\n};\n\n\n/**\n * Returns true if the object looks like an array. To qualify as array like\n * the value needs to be either a NodeList or an object with a Number length\n * property.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArrayLike = function(val) {\n  var type = goog.typeOf(val);\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\n};\n\n\n/**\n * Returns true if the object looks like a Date. To qualify as Date-like\n * the value needs to be an object and have a getFullYear() function.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a like a Date.\n */\ngoog.isDateLike = function(val) {\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\n};\n\n\n/**\n * Returns true if the specified value is a string\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\ngoog.isString = function(val) {\n  return typeof val == 'string';\n};\n\n\n/**\n * Returns true if the specified value is a boolean\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is boolean.\n */\ngoog.isBoolean = function(val) {\n  return typeof val == 'boolean';\n};\n\n\n/**\n * Returns true if the specified value is a number\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a number.\n */\ngoog.isNumber = function(val) {\n  return typeof val == 'number';\n};\n\n\n/**\n * Returns true if the specified value is a function\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is a function.\n */\ngoog.isFunction = function(val) {\n  return goog.typeOf(val) == 'function';\n};\n\n\n/**\n * Returns true if the specified value is an object.  This includes arrays\n * and functions.\n * @param {*} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\ngoog.isObject = function(val) {\n  var type = typeof val;\n  return type == 'object' && val != null || type == 'function';\n  // return Object(val) === val also works, but is slower, especially if val is\n  // not an object.\n};\n\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further\n * calls with the same object as a parameter returns the same value. The unique\n * ID is guaranteed to be unique across the current session amongst objects that\n * are passed into {@code getUid}. There is no guarantee that the ID is unique\n * or consistent across sessions. It is unsafe to generate unique ID for\n * function prototypes.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\ngoog.getUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // In Opera window.hasOwnProperty exists but always returns false so we avoid\n  // using it. As a consequence the unique ID generated for BaseClass.prototype\n  // and SubClass.prototype will be the same.\n  return obj[goog.UID_PROPERTY_] ||\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n};\n\n\n/**\n * Removes the unique ID from an object. This is useful if the object was\n * previously mutated using {@code goog.getUid} in which case the mutation is\n * undone.\n * @param {Object} obj The object to remove the unique ID field from.\n */\ngoog.removeUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // DOM nodes in IE are not instance of Object and throws exception\n  // for delete. Instead we try to use removeAttribute\n  if ('removeAttribute' in obj) {\n    obj.removeAttribute(goog.UID_PROPERTY_);\n  }\n  /** @preserveTry */\n  try {\n    delete obj[goog.UID_PROPERTY_];\n  } catch (ex) {\n  }\n};\n\n\n/**\n * Name for unique ID property. Initialized in a way to help avoid collisions\n * with other closure javascript on the same page.\n * @type {string}\n * @private\n */\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * Counter for UID.\n * @type {number}\n * @private\n */\ngoog.uidCounter_ = 0;\n\n\n/**\n * Adds a hash code field to an object. The hash code is unique for the\n * given object.\n * @param {Object} obj The object to get the hash code for.\n * @return {number} The hash code for the object.\n * @deprecated Use goog.getUid instead.\n */\ngoog.getHashCode = goog.getUid;\n\n\n/**\n * Removes the hash code field from an object.\n * @param {Object} obj The object to remove the field from.\n * @deprecated Use goog.removeUid instead.\n */\ngoog.removeHashCode = goog.removeUid;\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\n * refer to themselves will cause infinite recursion.\n *\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\n * UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {*} obj The value to clone.\n * @return {*} A clone of the input value.\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\n */\ngoog.cloneObject = function(obj) {\n  var type = goog.typeOf(obj);\n  if (type == 'object' || type == 'array') {\n    if (obj.clone) {\n      return obj.clone();\n    }\n    var clone = type == 'array' ? [] : {};\n    for (var key in obj) {\n      clone[key] = goog.cloneObject(obj[key]);\n    }\n    return clone;\n  }\n\n  return obj;\n};\n\n\n/**\n * A native implementation of goog.bind.\n * @param {Function} fn A function to partially apply.\n * @param {Object|undefined} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @private\n * @suppress {deprecated} The compiler thinks that Function.prototype.bind\n *     is deprecated because some people have declared a pure-JS version.\n *     Only the pure-JS version is truly deprecated.\n */\ngoog.bindNative_ = function(fn, selfObj, var_args) {\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\n};\n\n\n/**\n * A pure-JS implementation of goog.bind.\n * @param {Function} fn A function to partially apply.\n * @param {Object|undefined} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @private\n */\ngoog.bindJs_ = function(fn, selfObj, var_args) {\n  if (!fn) {\n    throw new Error();\n  }\n\n  if (arguments.length > 2) {\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      // Prepend the bound arguments to the current arguments.\n      var newArgs = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(newArgs, boundArgs);\n      return fn.apply(selfObj, newArgs);\n    };\n\n  } else {\n    return function() {\n      return fn.apply(selfObj, arguments);\n    };\n  }\n};\n\n\n/**\n * Partially applies this function to a particular 'this object' and zero or\n * more arguments. The result is a new function with some arguments of the first\n * function pre-filled and the value of |this| 'pre-specified'.<br><br>\n *\n * Remaining arguments specified at call-time are appended to the pre-\n * specified ones.<br><br>\n *\n * Also see: {@link #partial}.<br><br>\n *\n * Usage:\n * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');\n * barMethBound('arg3', 'arg4');</pre>\n *\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which |this| should\n *     point to when the function is run.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to the function.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n * @template T\n * @suppress {deprecated} See above.\n */\ngoog.bind = function(fn, selfObj, var_args) {\n  // TODO(nicksantos): narrow the type signature.\n  if (Function.prototype.bind &&\n      // NOTE(nicksantos): Somebody pulled base.js into the default\n      // Chrome extension environment. This means that for Chrome extensions,\n      // they get the implementation of Function.prototype.bind that\n      // calls goog.bind instead of the native one. Even worse, we don't want\n      // to introduce a circular dependency between goog.bind and\n      // Function.prototype.bind, so we have to hack this to make sure it\n      // works correctly.\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\n    goog.bind = goog.bindNative_;\n  } else {\n    goog.bind = goog.bindJs_;\n  }\n  return goog.bind.apply(null, arguments);\n};\n\n\n/**\n * Like bind(), except that a 'this object' is not required. Useful when the\n * target function is already bound.\n *\n * Usage:\n * var g = partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially\n *     applied to fn.\n * @return {!Function} A partially-applied form of the function bind() was\n *     invoked as a method of.\n */\ngoog.partial = function(fn, var_args) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Prepend the bound arguments to the current arguments.\n    var newArgs = Array.prototype.slice.call(arguments);\n    newArgs.unshift.apply(newArgs, args);\n    return fn.apply(this, newArgs);\n  };\n};\n\n\n/**\n * Copies all the members of a source object to a target object. This method\n * does not work on all browsers for all objects that contain keys such as\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\n * @param {Object} target Target.\n * @param {Object} source Source.\n */\ngoog.mixin = function(target, source) {\n  for (var x in source) {\n    target[x] = source[x];\n  }\n\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\n  // not enumerable on the prototype object (for example, isPrototypeOf from\n  // Object.prototype) but also it will not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n};\n\n\n/**\n * @return {number} An integer value representing the number of milliseconds\n *     between midnight, January 1, 1970 and the current time.\n */\ngoog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\n  // Unary plus operator converts its operand to a number which in the case of\n  // a date is done by calling getTime().\n  return +new Date();\n});\n\n\n/**\n * Evals javascript in the global scope.  In IE this uses execScript, other\n * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\n * global scope (for example, in Safari), appends a script tag instead.\n * Throws an exception if neither execScript or eval is defined.\n * @param {string} script JavaScript string.\n */\ngoog.globalEval = function(script) {\n  if (goog.global.execScript) {\n    goog.global.execScript(script, 'JavaScript');\n  } else if (goog.global.eval) {\n    // Test to see if eval works\n    if (goog.evalWorksForGlobals_ == null) {\n      goog.global.eval('var _et_ = 1;');\n      if (typeof goog.global['_et_'] != 'undefined') {\n        delete goog.global['_et_'];\n        goog.evalWorksForGlobals_ = true;\n      } else {\n        goog.evalWorksForGlobals_ = false;\n      }\n    }\n\n    if (goog.evalWorksForGlobals_) {\n      goog.global.eval(script);\n    } else {\n      var doc = goog.global.document;\n      var scriptElt = doc.createElement('script');\n      scriptElt.type = 'text/javascript';\n      scriptElt.defer = false;\n      // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\n      // .text doesn't work in Safari 2.  Therefore we append a text node.\n      scriptElt.appendChild(doc.createTextNode(script));\n      doc.body.appendChild(scriptElt);\n      doc.body.removeChild(scriptElt);\n    }\n  } else {\n    throw Error('goog.globalEval not available');\n  }\n};\n\n\n/**\n * Indicates whether or not we can call 'eval' directly to eval code in the\n * global scope. Set to a Boolean by the first call to goog.globalEval (which\n * empirically tests whether eval works for globals). @see goog.globalEval\n * @type {?boolean}\n * @private\n */\ngoog.evalWorksForGlobals_ = null;\n\n\n/**\n * Optional map of CSS class names to obfuscated names used with\n * goog.getCssName().\n * @type {Object|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMapping_;\n\n\n/**\n * Optional obfuscation style for CSS class names. Should be set to either\n * 'BY_WHOLE' or 'BY_PART' if defined.\n * @type {string|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMappingStyle_;\n\n\n/**\n * Handles strings that are intended to be used as CSS class names.\n *\n * This function works in tandem with @see goog.setCssNameMapping.\n *\n * Without any mapping set, the arguments are simple joined with a\n * hyphen and passed through unaltered.\n *\n * When there is a mapping, there are two possible styles in which\n * these mappings are used. In the BY_PART style, each part (i.e. in\n * between hyphens) of the passed in css name is rewritten according\n * to the map. In the BY_WHOLE style, the full css name is looked up in\n * the map directly. If a rewrite is not specified by the map, the\n * compiler will output a warning.\n *\n * When the mapping is passed to the compiler, it will replace calls\n * to goog.getCssName with the strings from the mapping, e.g.\n *     var x = goog.getCssName('foo');\n *     var y = goog.getCssName(this.baseClass, 'active');\n *  becomes:\n *     var x= 'foo';\n *     var y = this.baseClass + '-active';\n *\n * If one argument is passed it will be processed, if two are passed\n * only the modifier will be processed, as it is assumed the first\n * argument was generated as a result of calling goog.getCssName.\n *\n * @param {string} className The class name.\n * @param {string=} opt_modifier A modifier to be appended to the class name.\n * @return {string} The class name or the concatenation of the class name and\n *     the modifier.\n */\ngoog.getCssName = function(className, opt_modifier) {\n  var getMapping = function(cssName) {\n    return goog.cssNameMapping_[cssName] || cssName;\n  };\n\n  var renameByParts = function(cssName) {\n    // Remap all the parts individually.\n    var parts = cssName.split('-');\n    var mapped = [];\n    for (var i = 0; i < parts.length; i++) {\n      mapped.push(getMapping(parts[i]));\n    }\n    return mapped.join('-');\n  };\n\n  var rename;\n  if (goog.cssNameMapping_) {\n    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?\n        getMapping : renameByParts;\n  } else {\n    rename = function(a) {\n      return a;\n    };\n  }\n\n  if (opt_modifier) {\n    return className + '-' + rename(opt_modifier);\n  } else {\n    return rename(className);\n  }\n};\n\n\n/**\n * Sets the map to check when returning a value from goog.getCssName(). Example:\n * <pre>\n * goog.setCssNameMapping({\n *   \"goog\": \"a\",\n *   \"disabled\": \"b\",\n * });\n *\n * var x = goog.getCssName('goog');\n * // The following evaluates to: \"a a-b\".\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\n * </pre>\n * When declared as a map of string literals to string literals, the JSCompiler\n * will replace all calls to goog.getCssName() using the supplied map if the\n * --closure_pass flag is set.\n *\n * @param {!Object} mapping A map of strings to strings where keys are possible\n *     arguments to goog.getCssName() and values are the corresponding values\n *     that should be returned.\n * @param {string=} opt_style The style of css name mapping. There are two valid\n *     options: 'BY_PART', and 'BY_WHOLE'.\n * @see goog.getCssName for a description.\n */\ngoog.setCssNameMapping = function(mapping, opt_style) {\n  goog.cssNameMapping_ = mapping;\n  goog.cssNameMappingStyle_ = opt_style;\n};\n\n\n/**\n * To use CSS renaming in compiled mode, one of the input files should have a\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\n * mode, JavaScript code should be loaded before this base.js file that declares\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\n * are made in uncompiled mode.\n *\n * A hook for overriding the CSS name mapping.\n * @type {Object|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\n\n\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\n  // This does not call goog.setCssNameMapping() because the JSCompiler\n  // requires that goog.setCssNameMapping() be called with an object literal.\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\n}\n\n\n/**\n * Gets a localized message.\n *\n * This function is a compiler primitive. If you give the compiler a localized\n * message bundle, it will replace the string at compile-time with a localized\n * version, and expand goog.getMsg call to a concatenated string.\n *\n * Messages must be initialized in the form:\n * <code>\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\n * </code>\n *\n * @param {string} str Translatable string, places holders in the form {$foo}.\n * @param {Object=} opt_values Map of place holder name to value.\n * @return {string} message with placeholders filled.\n */\ngoog.getMsg = function(str, opt_values) {\n  var values = opt_values || {};\n  for (var key in values) {\n    var value = ('' + values[key]).replace(/\\$/g, '$$$$');\n    str = str.replace(new RegExp('\\\\{\\\\$' + key + '\\\\}', 'gi'), value);\n  }\n  return str;\n};\n\n\n/**\n * Gets a localized message. If the message does not have a translation, gives a\n * fallback message.\n *\n * This is useful when introducing a new message that has not yet been\n * translated into all languages.\n *\n * This function is a compiler primtive. Must be used in the form:\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\n * where MSG_A and MSG_B were initialized with goog.getMsg.\n *\n * @param {string} a The preferred message.\n * @param {string} b The fallback message.\n * @return {string} The best translated message.\n */\ngoog.getMsgWithFallback = function(a, b) {\n  return a;\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated,\n * unless they are exported in turn via this function or\n * goog.exportProperty\n *\n * <p>Also handy for making public items that are defined in anonymous\n * closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction',\n *                       Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is |goog.global|.\n */\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { }\n *\n * function ChildClass(a, b, c) {\n *   goog.base(this, a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // works\n * </pre>\n *\n * In addition, a superclass' implementation of a method can be invoked\n * as follows:\n *\n * <pre>\n * ChildClass.prototype.foo = function(a) {\n *   ChildClass.superClass_.foo.call(this, a);\n *   // other code\n * };\n * </pre>\n *\n * @param {Function} childCtor Child class.\n * @param {Function} parentCtor Parent class.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {};\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n};\n\n\n/**\n * Call up to the superclass.\n *\n * If this is called from a constructor, then this calls the superclass\n * contructor with arguments 1-N.\n *\n * If this is called from a prototype method, then you must pass\n * the name of the method as the second argument to this function. If\n * you do not, you will get a runtime error. This calls the superclass'\n * method with arguments 2-N.\n *\n * This function only works if you use goog.inherits to express\n * inheritance relationships between your classes.\n *\n * This function is a compiler primitive. At compile-time, the\n * compiler will do macro expansion to remove a lot of\n * the extra overhead that this function introduces. The compiler\n * will also enforce a lot of the assumptions that this function\n * makes, and treat it as a compiler error if you break them.\n *\n * @param {!Object} me Should always be \"this\".\n * @param {*=} opt_methodName The method name if calling a super method.\n * @param {...*} var_args The rest of the arguments.\n * @return {*} The return value of the superclass method.\n */\ngoog.base = function(me, opt_methodName, var_args) {\n  var caller = arguments.callee.caller;\n  if (caller.superClass_) {\n    // This is a constructor. Call the superclass constructor.\n    return caller.superClass_.constructor.apply(\n        me, Array.prototype.slice.call(arguments, 1));\n  }\n\n  var args = Array.prototype.slice.call(arguments, 2);\n  var foundCaller = false;\n  for (var ctor = me.constructor;\n       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {\n    if (ctor.prototype[opt_methodName] === caller) {\n      foundCaller = true;\n    } else if (foundCaller) {\n      return ctor.prototype[opt_methodName].apply(me, args);\n    }\n  }\n\n  // If we did not find the caller in the prototype chain,\n  // then one of two things happened:\n  // 1) The caller is an instance method.\n  // 2) This method was not called by the right caller.\n  if (me[opt_methodName] === caller) {\n    return me.constructor.prototype[opt_methodName].apply(me, args);\n  } else {\n    throw Error(\n        'goog.base called from a method of one name ' +\n        'to a method of a different name');\n  }\n};\n\n\n/**\n * Allow for aliasing within scope functions.  This function exists for\n * uncompiled code - in compiled code the calls will be inlined and the\n * aliases applied.  In uncompiled code the function is simply run since the\n * aliases as written are valid JavaScript.\n * @param {function()} fn Function to call.  This function can contain aliases\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\n *    (e.g. \"var Timer = goog.Timer\").\n */\ngoog.scope = function(fn) {\n  fn.call(goog.global);\n};\n\n\n",
		"goog.provide('H.map.render.RenderEngine');\n\n\ngoog.require('H.lang.InvalidArgumentError');\ngoog.require('H.math.Rect');\ngoog.require('H.util.EventTarget');\n\n\n\n/**\n * Abstract RenderEngine class. Render engines are used to render geographical position\n * set on the view model to the actual screen (viewport element). The rendered result may be\n * different for different engines, since every engine uses its onw capabilities and specific\n * implementation to present the current view model data in best possible way. In example\n * for 2D engines user will se mostly 2 dimensional flat map presented by tiles, on the other\n * hand 3D engines like panorama will display the same coordinates as a 'street view'.\n * In other words RenderEngine is responsible for managing the rendering loop as well as\n * for synchronizing rendered data with the view model and the data model.\n * It manages what and how gets rendered inside the current viewport.\n *\n *\n * @constructor\n * @param {H.map.ViewPort} viewPort\n * @param {H.map.ViewModel} viewModel\n * @param {H.map.DataModel} dataModel\n * @param {H.map.render.RenderEngine.Options} options\n * @extends {H.util.EventTarget}\n * @abstract\n * @export\n * @publish\n */\nH.map.render.RenderEngine = function(viewPort, viewModel, dataModel, options) {\n  'use strict';\n\n  var rect = new H.math.Rect(0, 0, 0, 0);\n\n  H.map.render.RenderEngine.superClass_.constructor.call(this);\n\n  this.pixelRatio = options['pixelRatio'];\n\n\n  /**\n   * A cache for view-port bounds\n   * @protected\n   * @type {Object.<H.map.render.RenderEngine.ViewPortBoundsType, ?(H.math.Rect)>}\n   */\n  this.viewPortBounds = {\n    1: rect.clone(),\n    2: rect.clone(),\n    4: rect.clone()\n  };\n\n\n  /**\n   * @protected\n   * @type {H.map.ViewPort}\n   */\n  this.viewPort = viewPort;\n\n  if (!viewPort) {\n    throw new H.lang.InvalidArgumentError(H.map.render.RenderEngine,\n        0, viewPort);\n  }\n  this.updateViewPortBounds_();\n  viewPort.addEventListener(viewPort.EventType.UPDATE, this.onResize, false, this);\n  this.startInteraction = H.lang.bind(this.startInteraction, this);\n  this.interaction = H.lang.bind(this.interaction, this);\n  this.endInteraction = H.lang.bind(this.endInteraction, this);\n  viewPort['startInteraction'] = this.startInteraction;\n  viewPort['interaction'] = this.interaction;\n  viewPort['endInteraction'] = this.endInteraction;\n\n\n  /**\n   * @protected\n   * @type {H.map.ViewModel}\n   */\n  this.viewModel = viewModel;\n\n  if (!viewModel) {\n    throw new H.lang.InvalidArgumentError(H.map.render.RenderEngine,\n        1, viewModel);\n  }\n  this.startControl = H.lang.bind(this.startControl, this);\n  this.control = H.lang.bind(this.control, this);\n  this.endControl = H.lang.bind(this.endControl, this);\n  viewModel['startControl'] = this.startControl;\n  viewModel['control'] = this.control;\n  viewModel['endControl'] = this.endControl;\n  viewModel.addEventListener(viewModel.EventType.UPDATE, this.onViewUpdate, false, this);\n\n\n  /**\n   * @protected\n   * @type {H.map.DataModel}\n   */\n  this.dataModel = dataModel;\n\n  if (!dataModel) {\n    throw new H.lang.InvalidArgumentError(H.map.render.RenderEngine,\n        2, dataModel);\n  }\n\n};\nH.lang.inherits(H.map.render.RenderEngine, H.util.EventTarget);\n\n\n/**\n * @protected\n * @type {number}\n */\nH.map.render.RenderEngine.prototype.pixelRatio;\n\n\n/**\n * The enumeration type of view-port bounds\n * @const\n * @enum {number}\n */\nH.map.render.RenderEngine.ViewPortBoundsType = {\n  /**\n   * The view-bounds according the margined ViewPort's size, respecting the possibly shifted padding center\n   * @const\n   */\n  MARGINED: 1,\n  /**\n   * The view-bounds according the visible ViewPort's size, respecting the possibly shifted padding center\n   * @const\n   */\n  VISIBLE: 2,\n  /**\n   * The view-bounds according the padded ViewPort's size, respecting the possibly shifted padding center\n   * @const\n   */\n  PADDED: 4\n};\n\n\n/**\n * To request the bounding box according the specified view port bounds type\n * @export\n * @abstract\n * @param {H.map.render.RenderEngine.ViewPortBoundsType} type The type of the requested view-bounds.\n * @param {number} margin A positive or negative margin in screen pixel to apply on each side of the bounds\n * @return {H.geo.Rect}\n * @method\n */\nH.map.render.RenderEngine.prototype.getBBox = goog.abstractMethod;\n\n\n/**\n * Updates the viewPortBounds_\n * @private\n */\nH.map.render.RenderEngine.prototype.updateViewPortBounds_ = function() {\n  'use strict';\n  var viewPort = this.viewPort,\n      width = viewPort['width'],\n      height = viewPort['height'],\n      padding = viewPort['padding'],\n      paddingTop = padding['top'],\n      paddingLeft = padding['left'],\n      paddingBottom = padding['bottom'],\n      paddingRight = padding['right'],\n      margin = viewPort['margin'],\n      left = -(width + paddingLeft - paddingRight) / 2 << 0,\n      top = -(height + paddingTop - paddingBottom) / 2 << 0,\n      right = width + left,\n      bottom = height + top,\n      viewPortBounds = this.viewPortBounds,\n      pixelRatio = this.pixelRatio;\n\n  viewPortBounds[H.map.render.RenderEngine.ViewPortBoundsType.MARGINED].set(\n      (left - margin) * pixelRatio, (top - margin) * pixelRatio,\n      (right + margin) * pixelRatio, (bottom + margin) * pixelRatio);\n  viewPortBounds[H.map.render.RenderEngine.ViewPortBoundsType.VISIBLE].set(\n      left * pixelRatio, top * pixelRatio,\n      right * pixelRatio, bottom * pixelRatio);\n  viewPortBounds[H.map.render.RenderEngine.ViewPortBoundsType.PADDED].set(\n      (left + paddingLeft) * pixelRatio, (top + paddingTop) * pixelRatio,\n      (right - paddingRight) * pixelRatio, (bottom - paddingBottom) * pixelRatio);\n\n};\n\n\n/**\n * Callback to react on \"sizechange\", \"paddingchange\" and \"marginchange\" events from the view port.\n * @protected\n */\nH.map.render.RenderEngine.prototype.onResize = function() {\n  'use strict';\n  this.updateViewPortBounds_();\n};\n\n\n/**\n * @protected\n */\nH.map.render.RenderEngine.prototype.disposeInternal = function() {\n  'use strict';\n  var viewModel = this.viewModel,\n      viewPort = this.viewPort;\n\n  viewModel.removeEventListener(viewModel.EventType.UPDATE, this.onViewUpdate, false, this);\n  if (viewModel['startControl'] === this.startControl) {\n    viewModel['startControl'] = H.map.ViewModel.prototype.startControl;\n  }\n  if (viewModel['control'] === this.control) {\n    viewModel['control'] = H.map.ViewModel.prototype.control;\n  }\n  if (viewModel['endControl'] === this.endControl) {\n    viewModel['endControl'] = H.map.ViewModel.prototype.endControl;\n  }\n\n  viewPort.removeEventListener(viewPort.EventType.UPDATE, this.onResize, false, this);\n  if (viewPort['startInteraction'] === this.startInteraction) {\n    viewPort['startInteraction'] =\n        H.map.ViewPort.prototype.startInteraction;\n  }\n  if (viewPort['interaction'] === this.interaction) {\n    viewPort['interaction'] = H.map.ViewPort.prototype.interaction;\n  }\n  if (viewPort['endInteraction'] === this.endInteraction) {\n    viewPort['endInteraction'] = H.map.ViewPort.prototype.endInteraction;\n  }\n};\n\n\n/**\n * Helper function to check if the interaction is bifocal,\n * returns true if all provided screen coords are numbers\n * @protected\n * @param {number|undefined} x\n * @param {number|undefined} y\n * @param {number|undefined} bx\n * @param {number|undefined} by\n * @return {boolean}\n */\nH.map.render.RenderEngine.prototype.isBifocalInteraction = function(x, y, bx, by) {\n  'use strict';\n  return x === +x && y === +y && bx === +bx && by === +by;\n};\n\n\n/**\n * A method to signal the begin of a control operation. A currently ongoing\n * control operation stops without kinetic effect. A currently control\n * operation also stops if viewModel was updated or beginInteraction was\n * called.\n * @param {H.util.kinetics.IKinetics=} opt_kinetics A kinetics to use when\n * the control ends. If {@code null}, no kinetic effect is performed.\n * @param {number=} opt_atX The X component of the screen coordinate where a\n * view control operation is applied. If <code>NaN</code> the screen center is\n * taken instead.\n * @param {number=} opt_atY The Y component of the screen coordinate where a\n * view control operation is applied. If <code>NaN</code> the screen center is t\n * aken instead.\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.startControl = goog.abstractMethod;\n\n\n/**\n * A method to process control operation.\n * If no control operation is currently ongoing ({@code beginControl} was not\n * triggered before or {@code endControl} was triggered meanwhile) the\n * {@code control} call is ignored.\n * @param {number} moveX The move of the camera in screen x axis as\n * levels per millisecond.\n * @param {number} moveY The move of the camera in screen x axis as\n * levels per millisecond.\n * @param {number} moveZ The move of the camera in screen z axis as levels\n * per millisecond.\n * @param {number} angleX The rotation of the camera on screen x axis as\n * degrees per millisecond.\n * @param {number} angleY The rotation of the camera on screen y axis as\n * degrees per millisecond.\n * @param {number} angleZ The rotation of the camera on screen z axis as\n * degrees per millisecond.\n * @param {number} zoom The zoom of the view as zoom levels per millisecond, ignored in <code>\"cam\"</code> mode.\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.control = goog.abstractMethod;\n\n\n/**\n * A method to signal the end of an control operation. If an {@code kinetics}\n * argument was passed to {@code beginControl} call, the kinetic effect is\n * performed.\n * If no control operation is currently ongoing ({@code beginControl} was not\n * triggered before or an {@code endControl} was triggered meanwhile) the\n * {@code endControl} call is ignored.\n * @param {boolean=} opt_preventKinetics if set to true kinetics\n * will not be fired\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.endControl = goog.abstractMethod;\n\n\n/**\n * A method to signal the begin of an interaction. A currently ongoing\n * interaction is stopped without kinetic effect.\n * Current interaction stopps if view model was changed or beginControl was\n * called.\n * @param {H.map.render.RenderEngine.InteractionModifiers} modifiers\n * @param {H.util.kinetics.IKinetics=} opt_kinetics\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.startInteraction = goog.abstractMethod;\n\n\n/**\n * A method to process an interaction based on screen coordinates of the\n * view port. If {@code beginInteraction} was triggered with a {@code modifiers}\n * argument of {@code COORD} combined with any other modifier but\n * {@code interaction} is called without bifocal coordinate then the\n * {@code COORD} modifier is ignored.\n * If no interaction is currently ongoing ({@code beginInteraction} was not\n * triggered before or an {@code endInteraction} was triggered meanwhile) the\n * {@code interact} call is ignored.\n * @param {number} x viewport x coordinate\n * @param {number} y viewport y coordinate\n * @param {number=} opt_bx x coordinate for second pointer/touch if present\n * @param {number=} opt_by y coordinate for secong pointer/touch if present\n * @param {number=} opt_timestamp known timestamp which should be passed\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.interaction = goog.abstractMethod;\n\n\n/**\n * Method signals the end of an interaction. If an {@code kinetics} was passed\n * to the previous {@code beginInteraction} call, the kinetic effect is\n * performed. If no interaction is currently ongoing ({@code beginInteraction}\n * was not triggered before or an {@code endInteraction} was triggered\n * meanwhile) the <code>endInteraction</code> call is ignored.\n * @param {boolean=} opt_preventKinetics\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.endInteraction = goog.abstractMethod;\n\n\n/**\n * Method converts pixel coordinates relative to the viewport's origin into a\n * geographic coordinates.\n * @param {number} x The X-coordinate of the pixel position\n * @param {number} y The Y-coordinate of the pixel position\n * @return {H.geo.IPoint} The translated geographic position\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.screenToGeo = goog.abstractMethod;\n\n\n/**\n * Method converts a geographic coordinates into a pixel position relative\n * to the viewport's origin.\n * @param {H.geo.IPoint} geoPoint\n * @return {?H.math.IPoint}\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.geoToScreen = goog.abstractMethod;\n\n\n/**\n * Calculates the best CameraModel to show the provided bounding rectangle\n * @param {H.geo.Rect} bounds The geographical bounding rectangle to use\n * @param {boolean} keepCenter To indicate whether the center of the bounds should be the resulting center\n * @return {H.map.ViewModel.CameraData} The result, represented by the\n * properties zoom (number) and position (geo.Point)\n * @export\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.getCamForBounds = goog.abstractMethod;\n\n\n/**\n * Method converts screen pixel coordinates to correct camera data object\n * @param {number} x X screen coordinate\n * @param {number} y Y screen coordinate\n * @return {H.map.ViewModel.CameraData}\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.screenToCameraData =\n    goog.abstractMethod;\n\n\n/**\n * Method returns visible objects under the given x/y screen coordinates. Array is sorted according to their drawing\n * order, topmost object has an index #0 in returned array.\n * @param {number} x x coordinate in screen space to probe renderer\n * @param {number} y y coordinate in screen space to probe renderer\n * @param {boolean=} opt_topMostOnly optional flag, if set method returns array with single element that is located\n * on top\n * @return {Array.<H.map.Object>}\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.getObjectsAt = goog.abstractMethod;\n\n\n/**\n * Method returns object that contains data on engine's possible camera angles,\n * modes etc.\n * @return {Object}\n * @abstract\n * @method\n */\n// TODO: capabilities reflection if necessary\nH.map.render.RenderEngine.prototype.getCapabilities = goog.abstractMethod;\n\n\n/**\n * Captures rectangular area of the surface.\n * Accepts only valid input: captured rect coordinates, should be contained by the surface\n * @param {number} x1 The X coordinate of the top left edge of the rect\n * @param {number} y1 The Y coordinate of the top left edge of the rect\n * @param {number} x2 The X coordinate of the bottom right edge of the rect\n * @param {number} y2 The Y coordinate of the bottom right edge of the rect\n * @return {HTMLCanvasElement} Captured\n */\nH.map.render.RenderEngine.prototype.capture = function(x1, y1, x2, y2) {\n  'use strict';\n  return null;\n};\n\n\n/**\n * Method informs render engine about the current pointer position relative to\n * the viewport. The position can be used by the render engine to provide\n * hover effects, tool tips etc. If the x argument is NaN the render engine\n * treats the given position outside the viewport.\n * @param {number} x The X coordinate of the pointer.\n * @param {number} y The Y coordinate of the pointer.\n * @abstract\n * @method\n * @export\n */\nH.map.render.RenderEngine.prototype.setPointer = goog.abstractMethod;\n\n\n/**\n * Method performs enter animation if one is available for the engine.\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.enter = goog.abstractMethod;\n\n\n/**\n * Method performs exit animation if one is available for the engine. Method\n * must not shut down the engine.\n * @param {function()} callback\n * @abstract\n * @method\n */\nH.map.render.RenderEngine.prototype.exit = goog.abstractMethod;\n\n\n/**\n * Protected method that facilitates engine's container fade out before exit\n * @protected\n * @param {Element} container\n * @param {function()} callback\n */\nH.map.render.RenderEngine.prototype.fadeout = function(container, callback) {\n  'use strict';\n  container.style.transition = 'opacity 1.5s';\n  container.addEventListener('transitionend', function(e) {\n    callback();\n  }, false);\n  container.style.opacity = 0;\n};\n\n\n/**\n * Interaction modifiers is a set of bitmask values that can be passed to\n * {@link H.map.render.RenderEngine#beginInteraction}\n * @typedef {Object}\n * @export\n */\nH.map.render.RenderEngine.InteractionModifiers = {\n  /**\n   * @type {number}\n   */\n  'ZOOM': 1,\n\n  /**\n   * @type {number}\n   */\n  'HEADING': 2,\n\n  /**\n   * @type {number}\n   */\n  'TILT': 4,\n\n  /**\n   * @type {number}\n   */\n  'INCLINE': 8,\n\n  /**\n   * @type {number}\n   */\n  'COORD': 16\n};\n\n\n//#################################################  EVENTS  ###########################################################\n/**\n * Events fired by RenderingEngine\n * @enum {string}\n */\nH.map.render.RenderEngine.prototype.EventType = {\n  RENDER: 'render'\n};\n\n\n/**\n * Fired when one of the layers or the engine (all layers) has been rendered completely.\n * The event target references either the completed layer or the render engine itself\n * @publish\n * @event H.map.render.RenderEngine#render\n * @type {H.util.Event}\n */\n\n\n//######################################################################################################################\n/**\n * @export\n * @enum {number}\n */\nH.map.render.RenderEngine.EngineType = {\n  'P2D': 0,\n  'PANORAMA': 1\n};\n\n\n/**\n * Options which may be used to initialize new RenderEngine instance\n *\n * @typedef {{\n *   pixelRatio: (number)\n * }}\n * @property {number} pixelRatio The pixelRatio to use for over-sampling in cases of high-resolution displays\n */\nH.map.render.RenderEngine.Options;\n"
	]
}